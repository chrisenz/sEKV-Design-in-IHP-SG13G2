---
title: "Design of the Symmetrical OTA"
subtitle: "Version 1"
author: "Christian Enz"
affiliation: "EPFL"
date: today
execute:
  echo: false
  warning: false
toc: true
number-sections: true
number-depth: 3
highlight-style: pygments
bibliography: references.bib
csl: ieee.csl
format: 
  html:
    include-in-header: mathjax.html
    code-fold: true
    html-math-method: mathjax
    css: styles.css
  pdf:
    keep-tex: true
    link-citations: true
    pdf-engine: pdflatex
    documentclass: scrreprt
    papersize: a4
    geometry: 
      - top=20mm
      - bottom=20mm
      - left=20mm
      - right=20mm
---

```{python}
#| init_cell: true

from ekv_functions import *

import pandas as pd
import matplotlib.pyplot as plt
import subprocess
import shutil
import os
import os.path as op
import sys
import re

from IPython.display import Markdown
from tabulate import tabulate
from matplotlib.ticker import EngFormatter

#plt.rcParams['text.usetex'] = True
plt.rcParams['svg.fonttype'] = 'none'
plt.rcParams['pdf.fonttype'] = 42
#plt.rcParams['ps.fonttype'] = 42
plt.rcParams['font.family'] = 'Arial'
#plt.rcParams['mathtext.fontset'] = 'cm'

plt.rcParams['mathtext.fontset'] = 'custom'
plt.rcParams['mathtext.rm'] = 'Arial'
plt.rcParams['mathtext.it'] = 'Arial:italic'
plt.rcParams['mathtext.bf'] = 'Arial:bold'

sys.path.append(".")
inkscapePath = r"C:\\Program Files\\Inkscape\\bin\\inkscape.exe"
#savePath = "./Figures/"
savePath = "./Plots/"

#plt.rcParams['text.usetex'] = True
plt.rcParams['svg.fonttype'] = 'none'
plt.rcParams['pdf.fonttype'] = 42
#plt.rcParams['ps.fonttype'] = 42
plt.rcParams['font.family'] = 'Arial'
#plt.rcParams['mathtext.fontset'] = 'cm'

plt.rcParams['mathtext.fontset'] = 'custom'
plt.rcParams['mathtext.rm'] = 'Arial'
plt.rcParams['mathtext.it'] = 'Arial:italic'
plt.rcParams['mathtext.bf'] = 'Arial:bold'

plt.style.use('plt_style_medium.mplstyle')
lw=1
msize=4
mevery=4

otaName="Symmetrical_OTA"
version = "_v1" # Allows you to save different versions
#newDesign=True
newDesign=False
#newSim=True
newSim=False
refloat=r'.*?([+-]?\d+([.]\d*)?([eE][+-]?\d+)?|[.]\d+([eE][+-]?\d+)?)'
```

# Introduction

![Schematic of the symmetrical differential OTA.](Figures/Symmetrical_OTA_schematic.png){#fig-symmetrical_ota_schematic}

::: {.callout-note}
Note that all nMOS transistors in @fig-symmetrical_ota_schematic have an odd number and all the pMOS transistors an even number which explains the numbering process (this is the reason why there is no M~6~ transistor!).
:::

This notebook presents the analysis, design and simulation of the symmetrical cascode OTA which schematic is presented in @fig-symmetrical_ota_schematic @bib:krummenacher:el:1:4:1981. The design phase is using the sEKV model and the inversion coefficient approach @bib:enz:book:2006, @bib:enz:sscmag:autumn:2017, @bib:enz:sscmag:winter:2017. The symmetrical OTA is a single-stage OTA having the dominant pole set by the load capacitance. It therefore doesn't require any compensation capacitance but can still achieve the gain of a two-stage OTA thanks to the cascode stages at the output at much lower current consumption. We will see below that in differential mode the effects of the source transconductances on the common source node voltage are actually canceled. In order to minimize the $V_{GS}$ voltage of M~1a~-M~1b~, we have chosen to put M~1a~-M~1b~ in a separate well at the cost of a larger area.

We will start with a detailed analysis of the OTA which will allow to derive all the design equations that will be used in the design phase. The OTA is then designed for a given set of specifications for the chosen IHP SG13G2 130nm BiCMOS technology @bib:ihp:2025. We have selected this technology because IHP provides an open source PDK which is then used for the validation of the design by simulation with ngspice @bib:ngspice:2024 using the PSP compact model @bib:psp103.6:2017 provided by the open source PDK @bib:ihp:2025.

# Analysis
## Small-signal analysis

![Small-signal schematic of the symmetrical cascode OTA.](Figures/Small-signal_schematics.png){#fig-ssc}

We start with the small-signal analysis. The small-signal schematic of the symmetrical OTA of @fig-symmetrical_ota_schematic is shown in @fig-ssc. The design of the symmetrical cascode OTA is similar to the design of the simple OTA, except that there are now more parasitic poles appearing at the various current mirror nodes. The small-signal output voltage in open-loop is given by
\begin{align}
  \Delta V_{out} =& \frac{A_{dc}}{1+s\,\tau_0} \cdot \left[\frac{\Delta V_{in+}}{1+s\,\tau_{p4}} - \frac{\Delta V_{in-}}{(1+s\,\tau_{p2})(1+s\,\tau_{p3})}\right.\\
  &\left.-\frac{\Delta V_{in+}+\Delta V_{in-}}{2(1+s\,\tau_{p1})} \cdot \left(\frac{1}{1+s\,\tau_{p4}} - \frac{1}{(1+s\,\tau_{p2})(1+s\,\tau_{p3}}\right)\right]
\end{align}
where
\begin{align}
  A_{dc} &= \frac{G_m}{G_o},\\
  G_m &= A_3 \cdot G_{m1},\\
  G_o &= \frac{G_{ds3b}\,G_{ds7}}{G_{ms7}} + \frac{G_{ds2d}\,G_{ds4}}{G_{ms4}},\\
  \tau_0 &= \frac{C_{out}}{G_o},\\
  C_{out} &= C_o + C_L,\\
  \tau_{p1} &= \frac{C_1}{2 G_{m1}},\\
  \tau_{p2} &= \frac{C_2}{G_{m2}},\\
  \tau_{p3} &= \frac{C_3}{G_{m3}},\\
  \tau_{p4} &= \frac{C_4}{G_{m2}}.
\end{align}

The unity-gain frequency or gain-bandwidth product is defined as $\omega_u = 1/\tau_u \triangleq A_{dc}/\tau_0 = G_m/C_{out}$. In most practical cases, we usually have $\tau_0 \gg \tau_{p2}, \tau_{p3}, \tau_{p4} > \tau_{p1}$.

For a differential input voltage $\Delta V_{id}=\Delta V_{in+}-\Delta V_{in-}$ with a constant common-mode voltage $V_{ic}$ and hence $\Delta V_{ic} = (\Delta V_{in+} + \Delta V_{in-})/2=0$, $\Delta V_{in+} = \Delta V_{in-} = \Delta V_{id}/2$, the differential mode small-signal open-loop gain reduces to
\begin{equation}
  A_{dm}(s) \triangleq \frac{\Delta V_{out}}{\Delta V_{id}} = \frac{1}{2} \cdot \frac{A_{dc}}{1+s\,\tau_0} \cdot \left[\frac{1}{1+s\,\tau_{p4}} - \frac{1}{(1+s\,\tau_{p2})(1+s\,\tau_{p3})}\right].
\end{equation}

The small-signal output voltage $\Delta V_{out}$ can also be written as
\begin{equation}\label{eqn:DVout_F_G}
  \Delta V_{out} = \frac{A_{dc}}{1+s\,\tau_0} \cdot \left[F(s) \cdot \Delta V_{in+} - G(s) \cdot \Delta V_{in-}\right],
\end{equation}
where
\begin{align}
  F(s) &= \frac{1}{1+s\,\tau_{p4}} - \frac{1}{2}\,\frac{1}{1+s\,\tau_{p1}} \cdot \left[\frac{1}{1+s\,\tau_{p4}} - \frac{1}{(1+s\,\tau_{p2})(1+s\,\tau_{p3})}\right],\\
  G(s) &= \frac{1}{(1+s\,\tau_{p2})(1+s\,\tau_{p3})} + \frac{1}{2}\,\frac{1}{1+s\,\tau_{p1}} \cdot \left[\frac{1}{1+s\,\tau_{p4}} - \frac{1}{(1+s\,\tau_{p2})(1+s\,\tau_{p3})}\right].
\end{align}

From \eqref{eqn:DVout_F_G} we see that the time constant $\tau_0$ introduces a $-90^\circ$ phase shift. Hence if the desired phase margin is at least $60^\circ$, the additional phase shift introduced by the smaller time constants $\tau_{p1}$, $\tau_{p2}$, $\tau_{p3}$ and $\tau_{p4}$ should not exceed $30^\circ$. In this range, the product $(1+s\,\tau_{p1})(1+s\,\tau_{p2})(1+s\,\tau_{p3})(1+s\,\tau_{p4})$ can be expanded and approximated by neglecting all the order terms higher than the first order term in $s$
\begin{equation}
  \prod_{k=1}^{4} (1+s\,\tau_{pk}) \cong 1 + s \, \sum_{k=1}^{4} \tau_{pk}.
\end{equation}
The above approximation gives a good estimation of the phase shift $\phi$ for $\phi < 30^\circ$, which correspond to the following frequency range
\begin{equation}
  \omega \leq \left(2\sum_{k=1}^{4} \tau_{pk}\right)^{-1}.
\end{equation}
Using the above approximation leads to
\begin{equation}
  F(s) \cong G(s) \cong \frac{1+s\,\tau_n}{1 + s\,\tau_d},
\end{equation}
where
\begin{align}
  \tau_n &= \tau_{p1} + \frac{\tau_{p2}+\tau_{p3}+\tau_{p4}}{2},\\
  \tau_d &= \tau_{p1}+\tau_{p2}+\tau_{p3}+\tau_{p4}.
\end{align}

For $\omega \leq 1/(2 \tau_d)$, the above expression can be further simplified considering that
\begin{equation}
  \frac{1+s\,\tau_n}{1 + s\,\tau_d} \cong \frac{1}{1 + s\,(\tau_d-\tau_n)}
\end{equation}
where
\begin{equation}
  \tau_d-\tau_n = \frac{\tau_{p2}+\tau_{p3}+\tau_{p4}}{2} = \frac{\tau_p}{2}.
\end{equation}

$F(s)$ and $G(s)$ become
\begin{equation}
  F(s) \cong G(s) \cong \frac{1}{1+s\,\frac{\tau_p}{2}},
\end{equation}
which is valid for $\omega \leq 1/(2 \tau_d) =1/(2(\tau_{p2}+\tau_p))$.

The simplified differential transfer function is then given by
\begin{equation}
  A_{dm}(s) \cong \frac{A_{dc}}{\left(1+s\,\tau_0\right)\left(1+s\,\frac{\tau_p}{2}\right)} = \frac{A_{dc}}{\left(1+\frac{s}{\omega_0}\right)\left(1+\frac{s}{\omega_p}\right)}
\end{equation}
with $\omega_0 \triangleq 1/\tau_0$ and $\omega_p \triangleq 2/\tau_p$ where it is assumed that $\tau_p = \tau_{p2}+\tau_{p3}+\tau_{p4} \ll \tau_0$. $\omega_0 \triangleq 1/\tau_0 \ll \omega_p$ is the dominant pole which is set by the load capacitance at the OTA output, whereas $\omega_p \triangleq 2/\tau_p$ represents the non-dominant pole related to all the time constants due to the parasitic capacitances at the current mirror nodes.

The transfer function can be further simplified as
\begin{equation}
  A_{dm}(s) \cong \frac{1}{s\,\tau_u\left(1+s\,\frac{\tau_p}{2}\right)} = \frac{1}{\frac{s}{\omega_u}\left(1+\frac{s}{\omega_p}\right)}
\end{equation}

where $\omega_u = 1/\tau_u = A_{dc} \cdot \omega_0 = G_m/C_{out}$ is the unity gain frequency or the gain-bandwidth product $GBW$ which is set by the OTA transconductance $G_m$ and the load capacitance $C_{out}$.

## Noise analysis
We have seen that the noise of the cascode transistors M~4~ and M~7~ can actually be neglected. Remembering that $A_3=A_1 \cdot A_2$, the PSD of the output noise current is given by
\begin{equation}
  S_{I_{nout}} = A_3^2\,\left(S_{I_{n1a}}+S_{I_{n1b}}+S_{I_{n2a}}+S_{I_{n2b}}\right) + A_2^2\,\left(S_{I_{n2c}}+S_{I_{n3a}}\right)+S_{I_{n2d}}+S_{I_{n3b}}
\end{equation}
or if we express the output PSD in terms of the output noise conductance
\begin{equation}
  S_{I_{nout}} =4 kT \cdot G_{nout}
\end{equation}
where
\begin{equation}
  G_{nout} = 2 A_3^2 \cdot (G_{n1}+G_{n2}) + A_2^2 \cdot (G_{n2c}+G_{n3a}) + G_{n2d} + G_{n3b}
\end{equation}
where we have assumed that M~1a~ and M~1b~ and M~2a~ and M~2b~ are identical. The $G_{ni}$ are given by
\begin{equation}
  G_{ni} = \gamma_{ni} \cdot G_{mi} + G_{mi}^2 \cdot \frac{\rho_i}{W_i\,L_i\,f} \qquad \textsf{for all transistors}.
\end{equation}

The input-referred noise resistance $R_{nin}$ is then given by
\begin{equation}
  R_{nin} \triangleq \frac{G_{nout}}{A_3^2 \cdot G_{m1}^2} = \frac{2(G_{n1}+G_{n2})}{G_{m1}^2} + \frac{G_{n2c}+G_{n3a}}{A_1^2 \cdot G_{m1}^2} + \frac{G_{n2d}+G_{n3b}}{A_3^2 \cdot G_{m1}^2}
\end{equation}
where we have used $A_3=A_1 \cdot A_2$. As expected, we see that the noise contribution to the input-referred noise of M~2d~ and M~3b~ is divided by $A_3^2$ and that from M~2c~ and M~3a~ is divided by $A_1^2$.

We now look at the input-referred thermal and flicker noise separately.

### Input-referred thermal noise
The input-referred thermal noise resistance is given by
\begin{equation}
  R_{nth} = \frac{2 \gamma_{n1}}{G_{m1}} \cdot (1 + \eta_{th})
\end{equation}
where
\begin{equation}
  \eta_{th} = \frac{\gamma_{n2}}{\gamma_{n1}}\,\frac{G_{m2}}{G_{m1}} + \frac{1}{2 A_1^2}\,\left(\frac{\gamma_{n2c}}{\gamma_{n1}}\,\frac{G_{m2c}}{G_{m1}} +\frac{\gamma_{n3a}}{\gamma_{n1}}\,\frac{G_{m3a}}{G_{m1}}\right) +\frac{1}{2 A_3^2}\,\left(\frac{\gamma_{n2d}}{\gamma_{n1}}\,\frac{G_{m2d}}{G_{m1}} +\frac{\gamma_{n3b}}{\gamma_{n1}}\,\frac{G_{m3b}}{G_{m1}}\right)
\end{equation}
represents the contributions to the input-referred thermal noise of the current mirrors relative to that of the differential pair. Now $G_{m2c}=A_1 \cdot G_{m2a}=A_1 \cdot G_{m2}$, $G_{m3b}=A_2 \cdot G_{m3a}=A_2 \cdot G_{m3}$ and $G_{m2d}=A_3 \cdot G_{m2b} = A_3 \cdot G_{m2}$, and assuming that $\gamma_{n2a}=\gamma_{n2b}\cong\gamma_{n2c}\cong\gamma_{n2d}=\gamma_{n2}$ and $\gamma_{n3a}\cong\gamma_{n3b}=\gamma_{n3}$, then $\eta_{th}$ reduces to
\begin{equation}
  \eta_{th} = \frac{\gamma_{n2}}{2\gamma_{n1}}\,\frac{G_{m2}}{G_{m1}} \left(2+\frac{1}{A_1}+\frac{1}{A_3}\right) +\frac{1}{2 A_1^2}\,\frac{\gamma_{n3}}{\gamma_{n1}}\,\frac{G_{m3}}{G_{m1}} \left(1+\frac{1}{A_2}\right)
\end{equation}

In the case of unity current gains $A_1=A_2=A_3=1$, $\eta_{th}$ simplifies further to
\begin{equation}
  \eta_{th} = 2 \frac{\gamma_{n2}}{\gamma_{n1}}\,\frac{G_{m2}}{G_{m1}} + \frac{\gamma_{n3}}{\gamma_{n1}}\,\frac{G_{m3}}{G_{m1}}
\end{equation}
Of course in the design process, we will try to minimize $\eta_{th}$ so that the dominant contribution to the input-referred thermal noise comes from the differential pair M~1a~-M~1b~.

We can also introduce the OTA thermal noise excess factor as
\begin{equation}
  \gamma_{ota} \triangleq G_m \cdot R_{nth},
\end{equation}
where $G_m = A_3 \cdot G_{m1}$ is the OTA transconductance. This results in
\begin{equation}
  \gamma_{ota} = 2 A_3 \cdot \gamma_{n1} \cdot (1 + \eta_{th}).
\end{equation}
We see that introducing some current gains larger than one in the current mirrors allows to reduce the contributions of transistors M~2c~-M~2d~ and M~3a~-M~3b~, but on the other hand increases the contribution of the differential pair and hence degrading (i.e. increasing) the OTA thermal noise excess factor $\gamma_{ota}$.

For $G_{m1} \gg G_{m2}$ and $G_{m1} \gg G_{m3}$, the noise is dominated by the differential pair and
\begin{equation}
  \gamma_{ota} \cong 2 A_3 \cdot \gamma_{n1}.
\end{equation}

For unity current gains $A_1=A_2=A_3=1$, the OTA thermal noise excess factor $\gamma_{ota}$ reduces to
\begin{equation}
  \gamma_{ota} \cong 2 \gamma_{n1}.
\end{equation}

### Input-referred flicker noise
The input-referred flicker noise resistance is given by
\begin{align}
  f \cdot R_{nfl} =& \frac{2 \rho_n}{W_1 L_1} + \rho_p\,\left(\frac{G_{m2}}{G_{m1}}\right)^2 \left(\frac{2}{W_2 L_2}+\frac{1}{W_{2c} L_{2c}}+\frac{1}{W_{2d} L_{2d}}\right)\\
  &+ \frac{\rho_n}{A_1^2}\left(\frac{G_{m3}}{G_{m1}}\right)^2\left(\frac{1}{W_{3a} L_{3a}}+\frac{1}{W_{3b} L_{3b}}\right)
\end{align}
which can be written as
\begin{equation}
  R_{nfl} = \frac{2 \rho_n}{W_1 L_1 f} \cdot (1 + \eta_{fl})
\end{equation}
where $\eta_{fl}$ represents the contributions to the input-referred flicker noise resistance of the current mirrors relative to that of the differential pair
\begin{align}
  \eta_{fl} =& \frac{\rho_p}{2\rho_n}\,\left(\frac{G_{m2}}{G_{m1}}\right)^2 \left(\frac{2 W_1 L_1}{W_2 L_2}+\frac{W_1 L_1}{W_{2c} L_{2c}}+\frac{W_1 L_1}{W_{2d} L_{2d}}\right)\\
  &+ \frac{1}{2 A_1^2}\left(\frac{G_{m3}}{G_{m1}}\right)^2\left(\frac{W_1 L_1}{W_{3a} L_{3a}}+\frac{W_1 L_1}{W_{3b} L_{3b}}\right).
\end{align}

For $A_1=A_2=A_3=1$, $W_{2a}=W_{2b}=W_{2c}=W_{2d}=W_2$, $L_{2a}=L_{2b}=L_{2c}=L_{2d}=L_2$, $W_{3a}=W_{3b}=W_3$ and $L_{3a}=L_{3b}=L_3$ reduces to
\begin{equation}
  \eta_{fl} = 2\frac{\rho_p}{\rho_n}\,\left(\frac{G_{m2}}{G_{m1}}\right)^2\,\frac{W_1 L_1}{W_2 L_2} + \left(\frac{G_{m3}}{G_{m1}}\right)^2\,\frac{W_1 L_1}{W_3 L_3}.
\end{equation}
Similarly to thermal noise, in the design process we will try to minimize $\eta_{fl}$ in order to reduce the input-referred flicker noise to the contribution of the differential pair M~1a~-M~1b~.

The corner frequency is obtained by equating $R_{nfl(f_k)} = R_{nth}$ resulting in
\begin{equation}
  f_k = \frac{\rho_n\,G_{m1}}{W_1\,L_1\,\gamma_{n1}} \cdot \frac{1+\eta_{fl}}{1+\eta_{th}}.
\end{equation}

## Input-referred offset voltage
The input-referred random offset voltage can be obtained in a similar way than noise. The variance of the input-referred offset voltage is given by
\begin{equation}\label{eqn:vos}
  \sigma_{V_{os}}^2 = \sigma_{V_{T1}}^2 \cdot (1 + \xi_{V_T}) + \left(\frac{I_b}{G_{m1}}\right)^2 \cdot \sigma_{\beta_1}^2 \cdot (1 + \xi_{\beta})
\end{equation}
where $\xi_{V_T}$ represents the $V_T$-mismatch contributions to the input-referred offset of the current mirrors relative to that of the differential pair
\begin{equation}\label{eqn:xivt1}
  \xi_{V_T} = 2 \left(\frac{G_{m2}}{G_{m1}}\right)^2 \cdot \frac{\sigma_{V_{T2}}^2}{\sigma_{V_{T1}}^2} + \left(\frac{G_{m3}}{A_1\,G_{m1}}\right)^2 \cdot \frac{\sigma_{V_{T3}}^2}{\sigma_{V_{T1}}^2}
\end{equation}
and $\xi_{\beta}$ represents the $\beta$-mismatch contributions to the input-referred offset of the current mirrors relative to that of the differential pair
\begin{equation}\label{eqn:xibeta1}
  \xi_{\beta} = 2 \frac{\sigma_{\beta_2}^2}{\sigma_{\beta_1}^2} + \frac{\sigma_{\beta_3}^2}{A_1^2\,\sigma_{\beta_1}^2}
\end{equation}
with
\begin{align}
  \sigma_{V_{T1}}^2 &= \frac{A_{VTn}^2}{W_1 L_1},\\
  \sigma_{V_{T2}}^2 &= \frac{A_{VTp}^2}{W_2 L_2},\\
  \sigma_{V_{T3}}^2 &= \frac{A_{VTn}^2}{W_3 L_3},
\end{align}
and
\begin{align}
  \sigma_{\beta_1}^2 &= \frac{A_{\beta n}^2}{W_1 L_1},\\
  \sigma_{\beta_2}^2 &= \frac{A_{\beta p}^2}{W_2 L_2},\\
  \sigma_{\beta_3}^2 &= \frac{A_{\beta n}^2}{W_3 L_3}.
\end{align}

Replacing in \eqref{eqn:xivt1} and \eqref{eqn:xibeta1} results in
\begin{equation}\label{eqn:xivt2}
  \xi_{V_T} = 2 \left(\frac{G_{m2}}{G_{m1}}\right)^2 \cdot \left(\frac{A_{VTp}}{A_{VTn}}\right)^2 \cdot \frac{W_1 L_1}{W_2 L_2} + \left(\frac{G_{m3}}{A_1\,G_{m1}}\right)^2 \cdot \frac{W_1 L_1}{W_3 L_3}
\end{equation}
and 
\begin{equation}\label{eqn:xibeta2}
  \xi_{\beta} = 2 \left(\frac{A_{\beta p}}{A_{\beta n}}\right)^2 \cdot \frac{W_1 L_1}{W_2 L_2} + \frac{1}{A_1^2}\,\frac{W_1 L_1}{W_3 L_3}
\end{equation}

Similarly to the flicker noise, the input-referred offset (variance or standard deviation) can be reduced by increasing the differential pair M~1a~-M~1b~ area $W_1 L_1$ but at the same time also increasing the area of the current mirrors $W_2 L_2$ (and hence $W_{2c} L_{2c}$ and $W_{2d} L_{2d}$) and depending on $A_1$ also the area of the current mirror M~3a~-M~3b~ $W_{3a} L_{3a}$ and $W_{3b} L_{3b}$. This obviously comes at the cost of increased parasitic capacitances at nodes 2, 3 and 4 that will unavoidably reduce the phase margin.

Having done the small-signal, noise and offset analysis, we can now proceed with the design.

# Design
## Specifications
The OTA specifications are given in @tbl-ota_specs.

::: {.callout-warning}
An important limitation of the IHP SC13G2 BiCMOS technology @bib:ihp:2025 is the high output conductance and hence limited intrinsic gain of nMOS transistors. Because of this, the specification on the DC gain, that was initially set to 80 dB, has been downgraded to 70 dB.
:::

::: {.callout-note}
The specifications given in @tbl-ota_specs are simplified specifications. They are mainly targeting the achievement of a certain gain-bandwidth product $GBW$ and DC gain at lowest current consumption. The $GBW$ sets the differential pair transconductance while the DC gain sets the output conductance. There is an additional specification on the random input-referred offset voltage which, if not met, might eventually require to increase the transistors area. There are no specifications on thermal noise since the transconductance is set by the $GBW$. There are no specifications on the flicker noise but if the corner frequency was set lower this would required to increase the transistors area. There are also no specifications on the slew-rate, which might be small because of the low-power objective. Finally, there are many more specifications such as CMRR, PSRR, input common-mode voltage range, output-voltage swing, etc... that are not discussed in this example.
:::

```{python}
#| label: tbl-ota_specs
#| tbl-cap: OTA specifications.

from specs import *

Adc=10**(AdcdB/20)
wu=2*pi*GBWspec
table = [["Minimum DC gain","$A_{{dc}}$",f'{AdcdB:.0f}',"$dB$"],
         ["Minimum gain-bandwidth product","$GBW$",f'{GBWspec/1e6:.3f}',"$MHz$"],
         ["Load capacitance","$C_L$",f'{CL/1e-12:.0f}',"$pF$"],
         ["Maximum input-referred random offset voltage","$V_{{os}}$",f'{Vosmax/1e-3:.0f}',"$mV$"],
         ["Phase margin","$PM$",f'{PMdeg:.0f}',"$^{\\circ}$"]
         ]
Markdown(tabulate(
  table,
  headers=["Specification","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center")
))
```


## Process
We will design the cascode gain stage for the open source IHP 13G2 BiCMOS process @bib:ihp:2025. The physical parameters are given in @tbl-physics_param, the global process parameters in @tbl-process_param and finally the MOSFET parameters in @tbl-mos_param. 

::: {.callout-warning}
The matching parameters for IHP 130nm are unknown. We will use those from a generic 180nm technology.
:::

```{python}
#| label: tbl-physics_param
#| tbl-cap: Physical parameters

from ihp130g2_sekv import *

table = [["$T$",f'{T:.0f}',"$K$"],
         ["$U_T$",f'{UT/1e-3:.3f}',"$mV$"]
         ]
Markdown(tabulate(
  table,
  headers=["Parameter","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center", "center", "center")
))
```

```{python}
#| label: tbl-process_param
#| tbl-cap: Process parameters.

table = [["$t_{{ox}}$",f'{tox/1e-9:.3f}',"$nm$","SiO~2~ oxyde thickness"],
         ["$C_{{ox}}$",f'{Cox*1e3:.3f}',"$\\frac{{fF}}{{\\mu m^2}}$","Oxyde capacitance per unit area"],
         ["$V_{{DD}}$",f'{VDD:.1f}',"$V$", "Nominal supply voltage"],
         ["$L_{{min}}$",f'{Lmin/1e-9:.0f}',"$nm$","Minimum drawn gate length"],
         ["$W_{{min}}$",f'{Wmin/1e-9:.0f}',"$nm$","Minimum drawn gate width"],
         ["$z_1$",f'{z1/1e-9:.0f}',"$nm$","Minimum outer diffusion width"],
         ["$z_2$",f'{z2/1e-9:.0f}',"$nm$","Minimum diffusion width between two fingers"]
        ]
Markdown(tabulate(
  table,
  headers=["Parameter","Value","Unit","Comment"],
  numalign="center",
  stralign="center",
  colalign=("center", "center", "center","left")
))
```

```{python}
#| label: tbl-mos_param
#| tbl-cap: Transistors parameters.

table = [["Length and width correction parameters for current"],
         ["$DL$",f'{DLn/1e-9:.0f}',f'{DLp/1e-9:.0f}',"$nm$"],
         ["$DW$",f'{DWn/1e-9:.0f}',f'{DWp/1e-9:.0f}',"$nm$"],
         ["Length and width correction for intrinsic and overlap capacitances"],
         ["$DLCV$",f'{DLCVn/1e-9:.0f}',f'{DLCVp/1e-9:.0f}',"$nm$"],
         ["$DWCV$",f'{DWCVn/1e-9:.0f}',f'{DWCVp/1e-9:.0f}',"$nm$"],
         ["Length and width correction parameter for fringing capacitances"],
         ["$DLGCV$",f'{DLGCVn/1e-9:.0f}',f'{DLGCVp/1e-9:.0f}',"$nm$"],
         ["$DWGCV$",f'{DWGCVn/1e-9:.0f}',f'{DWGCVp/1e-9:.0f}',"$nm$"],
         ["Long-channel sEKV parameters parameters"],
         ["$n$",f'{n0n:.2f}',f'{n0p:.2f}',"-"],
         ["$I_{{spec\\Box}}$",f'{Ispecsqn/1e-9:.0f}',f'{Ispecsqp/1e-9:.0f}',"$nA$"],
         ["$V_{{T0}}$",f'{VT0n/1e-3:.0f}',f'{VT0p/1e-3:.0f}',"$mV$"],
         ["Short-channel sEKV parameters parameters"],
         ["$L_{{sat}}$",f'{Lsatn/1e-9:.3f}',f'{Lsatp/1e-9:.3f}',"$nm$"],
         ["$\\lambda$",f'{lambdan*1e-6:.3f}',f'{lambdap*1e-6:.3f}',"$\\frac{{V}}{{\\mu m}}$"],
         ["Junction capacitances parameters"],
         ["$C_J$",f'{CJn*1e3:.3f}',f'{CJp*1e3:.3f}',"$\\frac{{fF}}{{\\mu m^2}}$"],
         ["$C_{{JSWSTI}}$",f'{CJSWSTIn*1e9:.3f}',f'{CJSWSTIp*1e9:.3f}',"$\\frac{{fF}}{{\\mu m}}$"],
         ["$C_{{JSWGAT}}$",f'{CJSWGATn*1e9:.3f}',f'{CJSWGATp*1e9:.3f}',"$\\frac{{fF}}{{\\mu m}}$"],
         ["Overlap capacitances parameters"],
         ["$C_{{GSo}}$",f'{CGSOn*1e9:.3f}',f'{CGSOp*1e9:.3f}',"$\\frac{{fF}}{{\\mu m}}$"],
         ["$C_{{GDo}}$",f'{CGDOn*1e9:.3f}',f'{CGDOp*1e9:.3f}',"$\\frac{{fF}}{{\\mu m}}$"],
         ["$C_{{GBo}}$",f'{CGBOn*1e9:.3f}',f'{CGBOp*1e9:.3f}',"$\\frac{{fF}}{{\\mu m}}$"],
         ["Fringing capacitances parameters"],
         ["$C_{{GSf}}$",f'{CGSFn*1e9:.3f}',f'{CGSFp*1e9:.3f}',"$\\frac{{fF}}{{\\mu m}}$"],
         ["$C_{{GDf}}$",f'{CGDFn*1e9:.3f}',f'{CGDFp*1e9:.3f}',"$\\frac{{fF}}{{\\mu m}}$"],
         ["Flicker noise parameters"],
         ["$K_F$",f'{KFn:.3e}',f'{KFp:.3e}',"$V A s$"],
         ["$AF$",f'{AFn:.1f}',f'{AFp:.1f}',"-"],
         ["$\\rho$",f'{rhon:.3e}',f'{rhop:.3e}',"$\\frac{{V m^2}}{{A s}}$"],
         ["Matching parameters"],
         ["$A_{{VT}}$",f'{AVTn*1e9:.0f}',f'{AVTp*1e9:.0f}',"$mV \\cdot \\mu m$"],
         ["$A_{{\\beta}}$",f'{Abetan*1e8:.0f}',f'{Abetap*1e8:.0f}',"$\\% \\cdot \\mu m$"]
        ]
Markdown(tabulate(
  table,
  headers=["Parameter","nMOS","pMOS","Unit"],
  numalign="center",
  stralign="center",
  colalign=("right", "center", "center","left")
))
```

## Design procedure

::: {.callout-important}
For this process, the transistor dimensions are rounded to 10nm. We also will ignore the length and width reduction parameters $DL$ and $DW$. The main reason is that most of the transistor length and width are sufficiently large that ignoring these parameters has little impact.
:::

```{python}
A1=1
A2=1
A3=A1*A2
```

We need to start with choosing the curent gain $A_3$. We have seen that having a current gain $A_3 > 1$ improves the transconductance but at the cost of a higher thermal noise excess factor $\gamma_{ota}$. We therefore will set to

$A_1 =$ `{python} f'{A1:.0f}'`,

$A_2 =$ `{python} f'{A2:.0f}'`,

$A_3 =$ `{python} f'{A3:.0f}'`.

Since $A_1 = A_2 = A_3 = 1$, transistors M~2a~, M~2b~, M~2c~ and M~2d~ are all identical and so are M~3a~ and M~3b~. We therefore have the following variables:

* M~1a~-M~1b~: $W_1$, $L_1$ and $I_b$. Note that the current $I_b$ is set by $G_{m1}$ because M~1a~-M~1b~ are biased in weak inversion,
* M~2a~-M~2c~ and M~2b~-M~2d~: $IC_2$, $W_2$ and $L_2$ since the current is already set,
* M~3a~-M~3b~: $IC_3$, $W_3$ and $L_3$ since the current is already set,
* M~4~: $IC_4$, $W_4$ and $L_4$ since the current is already set,
* M~7~: $IC_7$, $W_7$ and $L_7$ since the current is already set,
* M~5a~-M~5b~: $IC_5$, $W_5$ and $L_5$ since the current is already set.

We start sizing the differential pair M~1a~-M~1b~.

### Sizing the differential pair M~1a~-M~1b~
```{python}
Ibmin=2*pi*n0n*UT*CL*GBWspec
SRmin=Ibmin/CL
Ib=280E-9
IC1=0.1
Gm1=Ib/(n0n*UT)*gmsid_ic(IC1)
GBW=Gm1/(2*pi*CL)
WoverL1=Ib/(Ispecsqn*IC1)
Go=Gm1/Adc
L1=2*Ib/(lambdan*Go)
L1=round(1E8*L1)/1E8
W1=WoverL1*L1
W1=round(1E8*W1)/1E8
```

In this example there is no specification on the input-referred white noise. Therefore the transconductance $G_{m1}$ is set by the gain-bandwidth product according to
\begin{equation}
  GBW = \frac{G_{m1}}{2 \pi C_{out}},
\end{equation}
where $G_{m1}$ is the gate transconductance of M~1a~ and M~1b~ and $C_{out}$ the total output capacitance
\begin{equation}
  C_{out} = C_o + C_L
\end{equation}
with $C_o$ the parasitic capacitance at the output node and $C_L$ the specified load capacitance.

In order to minimize the input-referred noise and offset, the input differential pair should be biased in weak inversion. The transconductance $G_{m1}$ in deep weak inversion is then given by
\begin{equation}
  G_{m1} = \frac{I_b}{n U_T}.
\end{equation}
The bias current $I_b$ is the current flowing in each transistor M~1a~ and M~1b~ when the input differential voltage is zero. The bias current provided by M~5b~ is therefore $2 I_b$. The bias current must satisfy the following inequality:
\begin{equation}
  I_b \geq  2\pi n_{0n} U_T C_{out} GBW_{min}.
\end{equation}
which for the given specifications gives $I_{b,min}=$ `{python} f'{Ibmin/1e-9:.0f}'` $nA$. The corresponding slew-rate is then equal to $SR_{min} =$ `{python} f'{SRmin/1e3:.0f} '` $mV/\mu s$ which we will consider as sufficient. 

::: {.callout-important}
If the slew-rate is not sufficient, the bias current $I_b$ should be increased resulting in a higher current and power consumption. Other options include the use of a class AB OTA @bib:krummenacher:el:17:13:1981 or a dynamic/adaptive biasing OTA @bib:degrauwe:jssc:17:3:june:1982.
:::

As we will see below, the cascode transistors M~4~ and M~7~ will be biased in weak inversion to save voltage headroom at the output and preserve the output voltage swing of the symmetrical OTA. They will therefore be rather large transistors. Since they are connected to the output, they will increase the parasitic capacitance at the output $C_o$ due mostly to the junction capacitances. To have sufficient margin, we set $I_b =$ `{python} f'{Ib/1e-9:.0f}'` $nA$ and the inversion coefficient to $IC_1=$ `{python} f'{IC1:.1f}'`. The transconductance can be calculated from the $G_m/I_D$ function as $G_{m1} =$ `{python} f'{Gm1/1e-6:.3f}'` $\mu A/V$. This leads to a gain-bandwidth product

$GBW = \frac{G_{m1}}{2\pi\,C_L} =$ `{python} f'{GBW/1e6:.1f}'` $MHz$,

which is slightly higher than the target specification offering some margin. Knowing the drain current $I_{D1}$ and the inversion coefficient, we can calculate the $W/L$ aspect ratio for M~1a~-M~1b~ as $W_1/L_1 =$ `{python} f'{WoverL1:.1f}'`.

Before finalizing the sizing of the differential pair, we first will size the current mirrors.

### Sizing the pMOS current mirrors M~2a~-M~2c~ and M~2b~-M~2d~

```{python}
Vicmax=0.7
VGS1=VT0n+n0n*UT*vps_ic(IC1)
VDSsat1=UT*vdssat_ic(IC1)
VSG2=VDD-Vicmax+VGS1-VDSsat1
IC2=ic_vps((VSG2-VT0p)/(n0p*UT))
```

The gate voltage of M~2a~-M~2b~ should be set as low as possible for a given maximum common mode input voltage $V_{ic,max}$ still keeping M~1a~-M~1b~ in saturation. The source-to-gate voltage of M~2a~-M~2b~ $V_{SG2}$ is given by
\begin{equation}
  V_{SG2} = V_{DD} - V_{icmax} + V_{GS1} - V_{DSsat1}.
\end{equation}
The gate-to-source voltage $V_{GS1}$ and the saturation voltage $V_{DSsat1}$ of M~1a~-M~1b~ are given by $V_{GS1} =$ `{python} f'{VGS1/1e-3:.0f}'` $mV$ and $V_{DSsat1}  =$ `{python} f'{VDSsat1/1e-3:.0f}'` $mV$. For a maximum input common-mode voltage $V_{ic,max} =$ `{python} f'{Vicmax:.1f}'` $V$, the minimum source-to-gate voltage is given by $V_{SG2} =$ `{python} f'{VSG2/1e-3:.0f}'` $mV$, corresponding to an inversion coefficient $IC_2 =$ `{python} f'{IC2:.3f}'`.

```{python}
VSG2=VDD/2
IC2=ic_vps((VSG2-VT0p)/(n0p*UT))
VDSsat2=UT*vdssat_ic(IC2)
Ispec2=Ib/IC2
Gm2=Ispec2/(n0p*UT)*gms_ic(IC2)
WoverL2=Ispec2/Ispecsqp
```

We can set $V_{SG2}$ to $V_{SG2} = V_{DD}/2 =$ `{python} f'{VSG2/1e-3:.0f}'` $mV$ which corresponds to an inversion coefficient $IC_2 =$ `{python} f'{IC2:.3f}'` and a saturation voltage $V_{DSsat2}  =$ `{python} f'{VDSsat2/1e-3:.0f}'` $mV$. The specific current $I_{spec}$, transconductance $G_m$ and $W/L$ are then given by $I_{spec2} =$ `{python} f'{Ispec2/1e-9:.2f}'` $nA$, $G_{m2}  =$ `{python} f'{Gm2/1e-6:.3f}'` $\mu A/V$ and $W_2/L_2 =$ `{python} f'{WoverL2:.3f}'`.

```{python}
fp2GBW=10
fp2=fp2GBW*GBW
wp2=2*pi*fp2
C2=Gm2/wp2
CWL=2*Cox*(cgsi_ic(IC2)+cgbi_ic(IC2,n0p))
CW=2*(CGSOp+CGSFp+CGBOp)
W2=(-CW*WoverL2+sqrt(WoverL2)*sqrt(4*C2*CWL+CW**2*WoverL2))/(2*CWL)
#L2=(-CW*WoverL2+sqrt(WoverL2)*sqrt(4*C2*CWL+CW**2*WoverL2))/(2*CWL*WoverL2)
W2=round(1E8*W2)/1E8
L2=W2/WoverL2
L2=round(1E8*L2)/1E8
```

We now have to make sure that the non-dominant poles $f_{p2}$ and $f_{p4}$ at nodes 2 and 4 are sufficiently higher than the GBW to insure the desired phase margin. The non-dominant pole is given by
\begin{equation}
  \omega_{p2} = \frac{G_{m2}}{C_2},
\end{equation}
where $C_2$ is the total capacitance at node 2
\begin{equation}
 C_2 = 2(C_{GS2} + C_{GB2}).
\end{equation}
Assuming M~2a~-M~2b~ are in saturation, the gate-to-source capacitance $C_{GS2}$ is given by
\begin{equation}
  C_{GS2} \cong W_2\,L_2\,C_{ox} \cdot c_{gsi} + (C_{GSop} + C_{GSfp}) \cdot W_2,
\end{equation}
where $c_{gsi}$ is the intrinsic gate-to-source capacitance normalized to the total gate area $W\,L\,C_{ox}$, which is typically equal to $2/3$ in strong inversion and is proportionnal to $IC$ in weak inversion.

The gate-to-bulk capacitance $C_{GB2}$ is given by
\begin{equation}
  C_{GB2} \cong \,W_2\,L_2\,C_{ox} \cdot c_{gbi} + C_{GBop} \cdot W_2,
\end{equation}
where $c_{gbi}$ is the gate-to-bulk intrinsic capacitance normalized to the total gate area $W\,L\,C_{ox}$ and given by
\begin{equation}
  c_{gbi} = \frac{n-1}{n} \cdot c_{gsi}.
\end{equation}

The capacitance at node 2 then scales with $W_2$ and $L_2$ according to
\begin{equation}
  C_2 = W_2\,L_2 \cdot C_{WL} + W_2 \cdot C_W,
\end{equation}
with
\begin{align}
  C_{WL} &= 2\,C_{ox} \cdot (c_{gsi} + c_{gbi}),\\
  C_W &= 2(C_{GSop} + C_{GSfp} + G_{GBop}).
\end{align}

We already have set the inversion coefficient $IC_2 =$ `{python} f'{IC2:.3f}'`, from which we can calculate $c_{gsi} =$ `{python} f'{cgsi_ic(IC2):.3f}'` and $c_{gbi} =$ `{python} f'{cgbi_ic(IC2,n0p):.3f}'`. Since the $W/L$ has already been set by the transconductance and the current, we can derive $W_2$ and $L_2$ for achieving a given capacitance $C_2$ according to
\begin{align}
  W_2 &= \frac{-C_W \cdot W_2/L_2 + \sqrt{W_2/L_2} \cdot \sqrt{4\,C_2\,C_{WL}+C_W^2 \cdot W_2/L_2}}{2\,C_{WL}},\\
  L_2 &= \frac{W_2}{W_2/L_2}.
\end{align}

Setting the non-dominant pole $f_{p2}$ to `{python} f'{fp2GBW:.0f}'` times the $GBW$, we get $C_2 =$ `{python} f'{C2/1e-15:.0f}'` fF, $L_2 =$ `{python} f'{L2/1e-6:.2f}'` $\mu m$ and $W_2 =$ `{python} f'{W2/1e-9:.0f}'` $nm$.

Since $A_1=A_3=1$, M~2a~, M~2b~, M~2c~ and M~2d~ are all identical and hence $W_{2a} = W_{2b} = W_{2c} = W_{2d} =$ `{python} f'{W2/1e-9:.0f}'` $nm$ and $L_{2a} = L_{2b} = L_{2c} = L_{2d} =$ `{python} f'{L2/1e-6:.2f}'` $\mu m$.

We next size the nMOS current mirror M~3a~ and M~3b~.

### Sizing the nMOS current mirror M~3a~ and M~3b~
To size M~3a~ and M~3b~ we need to

* consider the output swing and
* make sure that M~2c~ remains in saturation for the chosen overdrive voltage chosen for M~3a~.

```{python}
Vosw=0.4
Vomin=(VDD-Vosw)/2
IC7=0.1
VDSsat7=UT*vdssat_ic(IC7)
VDSsat3=Vomin-VDSsat7
IC3=ic_vdssat(VDSsat3/UT)
VGS3a=VT0n+n0n*UT*vps_ic(IC3)
VSD2c=VDD-VGS3a
VDSsat2c=UT*vdssat_ic(IC2)
Ispec3=Ib/IC3
Gm3=Ispec3/(n0p*UT)*gms_ic(IC3)
WoverL3=Ispec3/Ispecsqn
```

Let's start maximizing the output swing assuming that we bias the cascode transistor M~7~ in weak inversion for minimum saturation voltage and maximum $G_m/I_D$. We set the inversion coefficient of M~7~ to $IC_7 =$ `{python} f'{IC7:.1f}'`. The saturation voltage of M~7~ is then given by $V_{DSsat7}  =$ `{python} f'{VDSsat7/1e-3:.0f}'` $mV$.

Let's say that we want an output swing of  `{python} f'{Vosw/1e-3:.0f}'` $mV$. This means that we have  `{python} f'{(VDD-Vosw)/1e-3:.0f}'` $mV$ to share between the positive and negative saturation voltages which we decide to split equally. This means  `{python} f'{(VDD-Vosw)/2/1e-3:.0f}'` $mV$ for the saturation voltages of M~7~ and M~3b~ which leaves a saturation voltage for M~3b~ of $V_{DSsat3}  =$ `{python} f'{VDSsat3/1e-3:.0f}'` $mV$. This corresponds to an inversion coefficient $IC_3 =$ `{python} f'{IC3:.1f}'`.

We now can check whether with the chosen inversion coefficient for M~3b~, M~2c~ remains in saturation. The gate-to-source voltage of M~3a~ is $V_{GS3a} =$ `{python} f'{VGS3a/1e-3:.0f}'` $mV$, giving a source to-drain voltage for M~2c~ $V_{SD2c} =$ `{python} f'{VSD2c/1e-3:.0f}'` $mV$, which is larger than its saturation voltage $V_{DSsat2c} =$ `{python} f'{VDSsat2c/1e-3:.0f}'` $mV$.

Knowing the current and the $IC_2 =$ `{python} f'{IC3:.1f}'`, we can deduce $I_{spec3} =$ `{python} f'{Ispec3/1e-9:.3f}'` $nA$, $W_3/L_3 =$ `{python} f'{WoverL3:.1e}'` and $G_{m3} =$ `{python} f'{Gm3/1e-6:.3f}'` $\mu A/V$.

```{python}
fp3GBW=10
fp3=fp3GBW*GBW
wp3=2*pi*fp3
C3=Gm3/wp3
CWL3=2*Cox*(cgsi_ic(IC3)+cgbi_ic(IC3,n0n))
CW3=2*(CGSOn+CGSFn+CGBOn)
W3=(-CW3*WoverL3+sqrt(WoverL3)*sqrt(4*C3*CWL3+CW3**2*WoverL3))/(2*CWL3)
W3=round(1E8*W3)/1E8
L3=W3/WoverL3
L3=round(1E8*L3)/1E8
```

Similarly to what was done for transistor M~2a~-M~2c~, we need to make sure that the non-dominant pole $f_{p3}$ at node 3 remains much higher than the $GBW$. Setting $f_{p3}/GBW=$ `{python} f'{fp3GBW:.0f}'` and proceeding in a similar way we get $f_{p3}/GBW =$ `{python} f'{fp3/GBW:.0f}'` with $C_3 =$ `{python} f'{C3/1e-15:.1f}'` $fF$ resulting in $W_3 =$ `{python} f'{W3/1e-9:.0f}'` $nm$ and $L_3 =$ `{python} f'{L3/1e-6:.2f}'` $\mu m$.

We see that $W_3$ is smaller than the minimum width. If we don't want to increase $W_3\,L_3$ and hence $C_3$, we need to reduce the inversion coefficient $IC_3$. We can find the $IC$ such that $W_3=W_{min}$ for the given $f_{p3}$ by looking at @fig-minimize_c3.

```{python}
from scipy.optimize import fsolve

def fic(IC):
    Ispec=Ib/IC
    Gm=Ispec/(n0n*UT)*gms_ic(IC)
    WoverL=Ispec/Ispecsqn
    C3=Gm/wp3
    CWL=2*Cox*(cgsi_ic(IC)+cgbi_ic(IC,n0n))
    W=(-CW*WoverL+sqrt(WoverL)*sqrt(4*C3*CWL+CW**2*WoverL))/(2*CWL)
#    print(W)
    return W-Wmin

fp3=fp3GBW*GBW
wp3=2*pi*fp3
CW=2*(CGSOn+CGSFn+CGBOn)
ICguess=20
ICopt=fsolve(fic,ICguess)
IC3ini=IC3
IC3=ICopt[0]
#print(f'ICopt = {IC3:.1f}')
Ispec3=Ib/IC3
Gm3=Ispec3/(n0n*UT)*gms_ic(IC3)
WoverL3=Ispec3/Ispecsqn
#W3=(-CWn*WoverL3+sqrt(WoverL3)*sqrt(4*C3*CWLn+CWn**2*WoverL3))/(2*CWLn)
W3=Wmin
L3=W3/WoverL3
CWL=2*Cox*(cgsi_ic(IC3)+cgbi_ic(IC3,n0n))
C3=W3*L3*CWL+W3*CW
wp3=Gm3/C3
fp3=wp3/(2*pi)
```


```{python}
#| label: fig-minimize_c3
#| fig-cap: "Length $L_3$ and width $W_3$ of M~3~ versus $IC_3$ for a given $f_{{p3}}/GBW$ ratio."

Npts=101
logICmin=-0
logICmax=2
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
IC=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)
W=np.zeros(Npts)
L=np.zeros(Npts)

fp3=10*GBWspec
wp3=2*pi*fp3
C3=Gm3/wp3
CWL=2*Cox*(2/3+(n0n-1)/(3*n0n))
CW=CGSOp

for k in range(0,Npts):
    Ispec=Ib/IC[k]
    Gm=Ispec/(n0p*UT)*gms_ic(IC[k])
    WoverL=Ispec/Ispecsqn
    C3=Gm/wp3
    W[k]=(-CW*WoverL+sqrt(WoverL)*sqrt(4*C3*CWL+CW**2*WoverL))/(2*CWL)
    L[k]=W[k]/WoverL

lw=1
plt.style.use('plt_style_small.mplstyle')
plt.loglog([ICmin,IC3],[Wmin/1e-9,Wmin/1e-9], 'k--', linewidth=lw)
plt.loglog([IC3,IC3],[1e-7,Wmin/1e-9], 'k--', linewidth=lw)
plt.loglog(IC, W/1e-9, 'r-', label='$W_3$')
plt.loglog(IC, L/1e-9, 'b-', label='$L_3$')
plt.xlim(ICmin,ICmax)
#plt.xticks(np.arange(0,24,2))
plt.xlabel('$IC_3$')
plt.ylim(100,1e5)
#plt.yticks(np.arange(0,22,2))
plt.ylabel('$W_3$ and $L_3$ [nm]')
#plt.legend(loc='lower left')
plt.legend(loc='upper left', fontsize=9)
textstr = f'$f_{{p3}} =$ {fp3/1e6:.1f} MHz'
plt.text(0.7, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.text(0.9, Wmin/1e-9, f'$W_{{min}} =$ {Wmin/1e-9:.0f}', ha='right', va='center', size=9)
plt.text(IC3, 85, f'$IC_{{3,opt}} =$ {IC3:.1f}', ha='left', va='top', size=9)
plt.show()
```

We get $IC_3 =$ `{python} f'{IC3:.1f}'`, $W_3 =$ `{python} f'{W3/1e-9:.0f}'` $nm$ and $L_3 =$ `{python} f'{L3/1e-6:.2f}'` $\mu m$ with $C_3 =$ `{python} f'{C3/1e-15:.1f}'` $fF$ and $f_{p3}/GBW =$ `{python} f'{fp3/GBWspec:.0f}'`.

The inversion coefficient of M~3a~-M~3b~ is therefore reduced from `{python} f'{IC3ini:.1f}'` to `{python} f'{IC3:.1f}'` in order to maintain a reasonable parasitic capacitance at node 3 to make sure that $f_{p3}$ is `{python} f'{fp3/GBWspec:.0f}'`-times higher than the $GBW$.

M~3b~ is identical to M~3a~ and therefore $W_{3a} = W_{3b} =$ `{python} f'{W3/1e-9:.0f}'` $nm$ and $L_{3a} = L_{3b} =$ `{python} f'{L3/1e-6:.2f}'` $\mu m$.

### Sizing the cascode transistors M~4~-M~7~
```{python}
Go=A3*Gm1/Adc
Ispec7=Ib/IC7
WoverL7=Ispec7/Ispecsqn
Gms7=Ib/UT*gmsid_ic(IC7)
Gds3=Ib/(lambdan*L3)
Gds7=Gms7/Gds3*Go/2
L7=Ib/(lambdan*Gds7)
L7=round(1E8*L7)/1E8
W7=WoverL7*L7
W7=round(1E8*W7)/1E8
VDSsat3=UT*vdssat_ic(IC3)
VGS7=VT0n
Vb2min=VDSsat3+VGS7
Vb2=VDD/2
```

The cascode transistors are sized according to the desired DC gain given by
\begin{equation}
  A_{dc} = \frac{A_3 \cdot G_{m1}}{G_o}
\end{equation}
with
\begin{equation}
  G_o = \frac{G_{ds3b} \cdot G_{ds7}}{G_{ms7}} + \frac{G_{ds2d} \cdot G_{ds4}}{G_{ms4}}
\end{equation}
The minimum DC gain specification is given by $A_{dc} =$ `{python} f'{Adc:.1e}'` or $A_{dc} =$ `{python} f'{AdcdB:.0f}'` dB. Since the transconductance $G_{m1}$ is already set by the $GBW$, the output conductance at the output node $G_o$ is then given by $G_o = G_{m1}/A_{dc} =$  `{python} f'{Go/1e-9:.3f}'` $nA/V$. We will split the output conductance equally between the nMOS and pMOS cascodes. We already have set the inversion coefficient of M~7~ to $IC_7 =$ `{python} f'{IC7:.1f}'`. Knowing the current, we can deduce the specific current $I_{spec7} =$ `{python} f'{Ispec7/1e-6:.1f}'` $\mu A$ and the aspect ratio $W_7/L_7 =$ `{python} f'{WoverL7:.1f}'`. Knowing the current and $IC_7$ we can get $G_{ms7} =$ `{python} f'{Gms7/1e-6:.3f}'` $\mu A/V$.

We already have chosen the length of M~3a~-M~3b~ $L_3 =$ `{python} f'{L3/1e-6:.2f}'` $\mu m$. The output conductance of M~3b~ can then be estimated to $G_{ds3} =$ `{python} f'{Gds3/1e-9:.3f}'` $nA/V$. We can then deduce the output conductance of M~7~ as $G_{ds7} =$ `{python} f'{Gds7/1e-9:.3f}'` $nA/V$ from which we deduce its length $L_7 =$ `{python} f'{L7/1e-6:.2f}'` $\mu m$.

```{python}
L7=1e-6
W7=WoverL7*L7
W7=round(1E8*W7)/1E8
```

To have some margin because of the high output conductance of nMOS transistors in this technology, we choose a slightly longer length $L_7 =$ `{python} f'{L7/1e-6:.2f}'` $\mu m$. Keeping the same $W_7/L_7 =$ `{python} f'{WoverL7:.1f}'`, we get $W_7 =$ `{python} f'{W7/1e-6:.2f}'` $\mu m$.

The minimum value of the bias voltage $V_{b2}$ is set such that M~3b~ remains in saturation
\begin{equation}
  V_{b2,min} = V_{DSsat3} + V_{GS2}.
\end{equation}
The saturation voltage of M~3b~ is equal to $V_{DSsat3} =$ `{python} f'{VDSsat3/1e-3:.0f}'` $mV$ and the $V_{GS}$ voltage of M~7~ is $V_{GS7} \cong$ `{python} f'{VGS7/1e-3:.0f}'` $mV$, which results $V_{b2,min} =$ `{python} f'{Vb2min/1e-3:.0f}'` $mV$. For convenience we choose $V_{b2} = V_{DD}/2 =$ `{python} f'{Vb2/1e-3:.0f}'` $mV$.

```{python}
IC4=IC7
VDSsat4=UT*vdssat_ic(IC4)
Ispec4=Ib/IC4
WoverL4=Ispec4/Ispecsqp
Gms4=Ib/UT*gmsid_ic(IC4)
Gds2=Ib/(lambdap*L2)
Gds4=Gms4/Gds2*Go/2
L4=Ib/(lambdap*Gds4)
L4=round(1E8*L4)/1E8
W4=WoverL4*L4
W4=round(1E8*W4)/1E8
```

For M~4~ we set the same inversion coefficient as M~7~ $IC_4 = IC_7 =$ `{python} f'{IC4:.1f}'`, from which we get its saturation voltage $V_{DSsat4} =$ `{python} f'{VDSsat4/1e-3:.0f}'` $mV$. Knowing the current and the $IC$ we can deduce $I_{spec4} =$ `{python} f'{Ispec4/1e-6:.1f}'` $\mu A$ and $W_4/L_4 =$ `{python} f'{WoverL4:.1f}'`. The source transconductance of M~4~ is then given by $G_{ms4} =$ `{python} f'{Gms4/1e-6:.3f}'` $\mu A/V$. The output conductance of M~2d~ can be estimated as $G_{ds2} =$ `{python} f'{Gds2/1e-9:.3f}'` $nA/V$. We can then deduce the output conductance of M~4~ $G_{ds4} =$ `{python} f'{Gds4/1e-9:.3f}'` $nA/V$, from which we can calculate the length $L_4 =$ `{python} f'{L4/1e-9:.0f}'` $nm$, which is smaller than the minimum length.

```{python}
L4=250e-9
W4=WoverL4*L4
W4=round(1E8*W4)/1E8
```

We could choose $L_4 = L_{min}$, but in order to have some margin on the DC gain, we choose $L_4 =$ `{python} f'{L4/1e-9:.0f}'` $nm$. Keeping the same $W_4/L_4 =$ `{python} f'{WoverL4:.1f}'`, this leads to $W_4 =$ `{python} f'{W4/1e-6:.2f}'` $\mu m$.

```{python}
VSDsat2=UT*vdssat_ic(IC2)
VSG4=VT0p
Vb1max=VDD-VSDsat2-VSG4
Vb1=0.5
```

The maximum value of the bias voltage $V_{b1}$ is limited by the saturation voltage of M~2d~ according to
\begin{equation}\label{eqn:}
  V_{b1,max} = V_{DD} - V_{SDsat2d} - V_{SG4}.
\end{equation}
The saturation voltage of M~2d~ is $V_{SDsat2} =$ `{python} f'{VSDsat2/1e-3:.0f}'` $mV$ and the source-to-gate voltage of M~4~ is $V_{SG4} \cong$ `{python} f'{VSG4/1e-3:.0f}'` $mV$, leading to $V_{b1,max} \cong$ `{python} f'{Vb1max/1e-3:.3f}'` $mV$. For convenience, we can also set $V_{b1} = V_{DD}/2 =$ `{python} f'{Vb1/1e-3:.0f}'` $mV$.

```{python}
Gds3b=Ib/(lambdan*L3)
Ispec7=Ispecsqn*W7/L7
IC7=Ib/Ispec7
Gms7=Ib/UT*gmsid_ic(IC7)
Gds7=Ib/(lambdan*L7)
Gon=Gds3b*Gds7/Gms7
Gds2d=Ib/(lambdap*L2)
Ispec4=Ispecsqp*W4/L4
IC4=Ib/Ispec4
Gms4=Ib/UT*gmsid_ic(IC4)
Gds4=Ib/(lambdap*L4)
Gop=Gds2d*Gds4/Gms4
Go=Gon+Gop
Adcest=Gm1/Go
AdcdBest=20*log(Adcest)
```

We can now check the resulting DC gain. The output conductance of the nMOS and pMOS cascodes are $G_{on} =$ `{python} f'{Gon/1e-12:.3f}'` $pA/V$ and $G_{op} =$ `{python} f'{Gop/1e-12:.3f}'` $pA/V$, respectively. This results in a total output conductance $G_o =$ `{python} f'{Go/1e-12:.3f}'` $pA/V$ and a DC gain $A_{dc} =$ `{python} f'{Adcest:.0e}'` or $A_{dc} =$ `{python} f'{AdcdBest:.1f}'` dB, which is 10 dB higher than the specifications.

### Sizing the nMOS current mirror M~5a~-M~5b~

```{python}
Vicmin=0.4
VGS1=VT0n+n0n*UT*vps_ic(IC1)
VDSsat5=Vicmin-VGS1
IC5=ic_vdssat(VDSsat5/UT)
Ispec5=2*Ib/IC5
WoverL5=Ispec5/Ispecsqn
W5=Wmin
L5=W5/WoverL5
L5=round(1E8*L5)/1E8
```

Finally we need to size M~5a~-M~5b~. The minimum input common mode voltage $V_{ic,min}$ is limited by the saturation voltage of M~5b~ according to
\begin{equation}
  V_{ic,min} = V_{GS1} + V_{DSsat5b}.
\end{equation}
Since M~1a~-M~1b~ are in a separate well, their gate-to-source voltage is $V_{GS1} = V_{T0n} + n\,U_T\,(v_p-v_s) \cong$ `{python} f'{VGS1/1e-3:.0f}'` $mV$. Setting the minimum input common mode voltage to $V_{ic,min} =$ `{python} f'{Vicmin/1e-3:.0f}'` $mV$ leads to the maximum saturation voltage of M~5b~ $V_{DSsat5} = V_{ic,min} - V_{GS1} \cong$ `{python} f'{VDSsat5/1e-3:.0f}'` $mV$. The corresponding inversion coefficient of M~5b~ is $IC_5 =$ `{python} f'{IC5:.1f}'`. From $I_b$ and $IC_5$ we get $I_{spec5} =$ `{python} f'{Ispec5/1e-9:.3f}'` $nA$ and $W_5/L_5 =$ `{python} f'{WoverL5:.3e}'`. With such a low $W/L$ ratio, we need to set $W_5$ to the minimum width $W_5 = W_{min} =$ `{python} f'{W5/1e-9:.0f}'` $nm$ from which we deduce $L_5 =$ `{python} f'{L5/1e-6:.2f}'` $\mu m$.

Transistor M~5a~ is identical to M~5b~ and hence $W_{5a} = W_{5b} =$ `{python} f'{W5/1e-9:.0f}'` $nm$ and $L_{5a} = L_{5b} =$ `{python} f'{L5/1e-6:.2f}'` $\mu m$.

The sizing process is almost finished, but we still need to finalize the sizing of the differential pair M~1a~-M~1b~.

### Final sizing of the differential pair M~1a~-M~1b~

```{python}
flickerfactor=1
WL1=flickerfactor/(rhop/rhon*(Gm2/Gm1)**2*2/(W2*L2)+(Gm3/Gm1)**2/(W3*L3))
W1=sqrt(WoverL1*WL1)
W1=round(1E8*W1)/1E8
L1=sqrt(WL1/WoverL1)
L1=round(1E8*L1)/1E8
flickerpMOSCM=rhop/rhon*(Gm2/Gm1)**2*2*W1*L1/(W2*L2)
flickernMOSCM=(Gm3/Gm1)**2*W1*L1/(W3*L3)
gamman1=gamman_ic(IC1,n0n)
gamman2=gamman_ic(IC2,n0p)
gamman3=gamman_ic(IC3,n0n)
etath=2*gamman2/gamman1*Gm2/Gm1+gamman3/gamman1*Gm3/Gm1
gammaota=2*gamman1*(1+etath)
Rninth=gammaota/Gm1
Sninth=4*kT*Rninth
SninthdBv=10*log(Sninth)
etafl=2*rhop/rhon*(Gm2/Gm1)**2*W1*L1/(W2*L2)+(Gm3/Gm1)**2*W1*L1/(W3*L3)
fk=rhon*Gm1/(W1*L1*gamman1)*(1+etafl)/(1+etath)
```

We haven't finalized the sizing of M~1a~-M~1b~. We already have the $W/L$ ratio but still need to set $W_1$ and $L_1$. We don't have any specifications on the noise and particularly the corner frequency, while the white noise is already set by the transconductance $G_{m1}$.

Since the current mirrors current gains are all unity $A_1=A_2=A_3=1$, the transistors M~2a~, M~2b~, M~2c~ and M~2d~ are all identical. In this case the contributions of the current mirrors to the input-referred flicker noise relative to the contribution of the differential pair is captured by the $\eta_{fl}$ parameter recalled below
\begin{equation}
  \eta_{fl} = 2\,\frac{\rho_p}{\rho_n} \cdot \left(\frac{G_{m2}}{G_{m1}}\right)^2\,\frac{W_1 L_1}{W_2 L_2} + \left(\frac{G_{m3}}{G_{m1}}\right)^2 \cdot \frac{W_1 L_1}{W_3 L_3}.
\end{equation}
The ratio of the flicker noise parameter of pMOS transistors to that of nMOS transistors is given by $\rho_p/\rho_n =$ `{python} f'{rhop/rhon:.3f}'`, which is rather large. The square of the transconductance ratio $(G_{m1}/G_{m2})^2 =$ `{python} f'{(Gm1/Gm2)**2:.3f}'` should compensate for this large $\rho_p/\rho_n$ ratio. We can try to make the contribution of the input differential pair equal to the contribution of the current mirrors (i.e. set $\eta_{fl}=1$). This results in $W_1 \cdot L_1 =$ `{python} f'{WL1/1e-12:.3f}'` $\mu m^2$.

Since we already have $W_1/L_1$ we can deduce $W_1 =$ `{python} f'{W1/1e-6:.2f}'` $\mu m$ and $L_1 =$ `{python} f'{L1/1e-9:.0f}'` $nm$. Since transistor M~1a~ is identical to M~1b~, we have $W_{1a} = W_{1b} =$ `{python} f'{W1/1e-6:.2f}'` $\mu m$ and $L_{1a} = L_{1b} =$ `{python} f'{L1/1e-9:.0f}'` $nm$.

The relative contribution to the input-referred flicker noise of the pMOS current mirrors M~2a~ to M~2d~ is `{python} f'{flickerpMOSCM:.3f}'`, whereas that of the nMOS current mirror M~3a~ and M~3b~ is `{python} f'{flickernMOSCM:.3f}'`. This leads to $\eta_{fl} =$ `{python} f'{etafl:.3f}'`, which is close to the desired $\eta_{fl} \cong 1$.

We now have finalized the design. We can still check the thermal noise. The OTA thermal noise excess factor $\gamma_{ota}$ and the input-referred white noise PSD are given by

$\eta_{th} =$ `{python} f'{etath:.3f}'`,

$\gamma_{ota} =$ `{python} f'{gammaota:.1f}'`,

$R_{ninth} =$ `{python} f'{Rninth/1e3:.1f}'` $k\Omega$,

$S_{ninth} =$ `{python} f'{Sninth:.1e}'` $\frac{V^2}{Hz}$,

$\sqrt{S_{ninth}} =$ `{python} f'{sqrt(Sninth)/1e-9:.1f}'` $\frac{nV}{\sqrt{Hz}}$,

$10 \cdot \log(S_{ninth}) =$ `{python} f'{SninthdBv:.1f}'` $\frac{dBv}{\sqrt{Hz}}$.

This sets the corner frequency to $f_k =$ `{python} f'{fk/1e3:.1f}'` $kHz$.

The design is now finalized and is summarized in the section.

## Summary
### Specifications
The specifications are recalled in @tbl-ota_specs2.

```{python}
#| label: tbl-ota_specs2
#| tbl-cap: OTA specifications.

ota_specs_df=pd.DataFrame(
{
    "Name": ["AdcdB","GBWspec","CL","Vosmax","PMdeg"],
    "Value": [AdcdB,GBWspec,CL,Vosmax,PMdeg]
})
#pd.set_option('display.float_format', '{:.2E}'.format)
#ota_specs_df

Adc=10**(AdcdB/20)
wu=2*pi*GBWspec
table = [["Minimum DC gain","$A_{{dc}}$",f'{AdcdB:.0f}',"$dB$"],
         ["Minimum gain-bandwidth product","$GBW$",f'{GBWspec/1e6:.3f}',"$MHz$"],
         ["Load capacitance","$C_L$",f'{CL/1e-12:.0f}',"$pF$"],
         ["Maximum input-referred random offset voltage","$V_{{os}}$",f'{Vosmax/1e-3:.0f}',"$mV$"],
         ["Phase margin","$PM$",f'{PMdeg:.0f}',"$^{\\circ}$"]
         ]
Markdown(tabulate(
  table,
  headers=["Specification","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center")
))
```

### Bias
The bias information are summarized in @tbl-ota_bias.

```{python}
#| label: tbl-ota_bias
#| tbl-cap: OTA bias.

ota_bias_df=pd.DataFrame(
{
    "Name": ["VDD","Ib","Vb1","Vb2"],
    "Value": [VDD,Ib,Vb1,Vb2]
})
#pd.set_option('display.float_format', '{:.1E}'.format)
#ota_bias_df

table = [["Supply voltage","$V_{{DD}}$",f'{VDD:.1f}',"$V$"],
         ["Bias current","$I_b$",f'{Ib/1e-9:.0f}',"$nA$"],
         ["Cascode bias voltage","$V_{{b1}}$",f'{Vb1:.1f}',"$V$"],
         ["Cascode bias voltage","$V_{{b2}}$",f'{Vb2:.1f}',"$V$"]
         ]
Markdown(tabulate(
  table,
  headers=["Bias voltage or current","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center"),
  floatfmt=".1f"
))
```

### Transistor information
The transistor sizes and large-signal variables are summarized in @tbl-transistor_info1, whereas @tbl-transistor_info2 gives the small-signal and thermal noise parameters. An Excel table is generated with more information (e.g. all the parasitic capacitances).

```{python}
#| label: tbl-transistor_info1
#| tbl-cap: Transistor size and bias information.

excelFilename = otaName + version + ".xlsx"

transistor_info={
    "Type": ["n","n","p","p","p","p","n","n","p","n","n","n"],
    "Function": ["DP","DP","CM","CM","CM","CM","CM","CM","CA","CM","CM","CA"],
    "W": [W1,W1,W2,W2,W2,W2,W3,W3,W4,W5,W5,W7],
    "L": [L1,L1,L2,L2,L2,L2,L3,L3,L4,L5,L5,L7],
    "ID": [Ib,Ib,Ib,Ib,Ib,Ib,Ib,Ib,Ib,2*Ib,2*Ib,Ib]
}
transistor_list=["M1a","M1b","M2a","M2b","M2c","M2d","M3a","M3b","M4","M5a","M5b","M7"]
ota_df=pd.DataFrame(transistor_info, index=transistor_list)

ota_df["W/L"]=ota_df["W"]/ota_df["L"]
ota_df["AD"]=ota_df["W"]*z1
ota_df["PD"]=2*(ota_df["W"]+z1)
ota_df["AS"]=ota_df["AD"]
ota_df["PS"]=ota_df["PD"]
ota_df["Ispec"]=np.where(ota_df["Type"]=="n",
                                     ota_df["W/L"]*Ispecsqn,
                                     ota_df["W/L"]*Ispecsqp)
ota_df["IC"]=ota_df["ID"]/ota_df["Ispec"]
ota_df["VP-VS"]=UT*vps_ic(ota_df["IC"])
ota_df["n"]=np.where(ota_df["Type"]=="n",
                                     n0n,
                                     n0p)
ota_df["VG-VT0"]=np.where(ota_df["Type"]=="n",
                                     ota_df["VP-VS"]/n0n,
                                     ota_df["VP-VS"]/n0p)
ota_df["VDSsat"]=UT*vdssat_ic(ota_df["IC"])
ota_df["Gspec"]=ota_df["Ispec"]/UT
ota_df["Gms"]=ota_df["Gspec"]*gms_ic(ota_df["IC"])
ota_df["Gm"]=np.where(ota_df["Type"]=="n",
                                     ota_df["Gms"]/n0n,
                                     ota_df["Gms"]/n0p)
ota_df["Gds"]=np.where(ota_df["Type"]=="n",
                                     ota_df["ID"]/(lambdan*ota_df["L"]),
                                     ota_df["ID"]/(lambdap*ota_df["L"]))
ota_df["gamman"]=np.where(ota_df["Type"]=="n",
                                     gamman_ic(ota_df["IC"],n0n),
                                     gamman_ic(ota_df["IC"],n0p))
ota_df["COX"]=Cox*ota_df["W"]*ota_df["L"]
ota_df["CGSi"]=ota_df["COX"]*cgsi_ic(ota_df["IC"])
ota_df["CGDi"]=0
ota_df["CGBi"]=np.where(ota_df["Type"]=="n",
                                     ota_df["COX"]*cgbi_ic(ota_df["IC"],n0n),
                                     ota_df["COX"]*cgbi_ic(ota_df["IC"],n0p))
ota_df["CBSi"]=np.where(ota_df["Type"]=="n",
                                     ota_df["COX"]*cbsi_ic(ota_df["IC"],n0n),
                                     ota_df["COX"]*cbsi_ic(ota_df["IC"],n0p))
ota_df["CBDi"]=np.where(ota_df["Type"]=="n",
                                     ota_df["CGDi"]*(n0n-1),
                                     ota_df["CGDi"]*(n0p-1))
ota_df["CGSo"]=np.where(ota_df["Type"]=="n",
                                     ota_df["W"]*CGSOn,
                                     ota_df["W"]*CGSOp)
ota_df["CGDo"]=np.where(ota_df["Type"]=="n",
                                     ota_df["W"]*CGDOn,
                                     ota_df["W"]*CGDOp)
ota_df["CGBo"]=np.where(ota_df["Type"]=="n",
                                    ota_df["W"]*CGBOn,
                                    ota_df["W"]*CGBOp)
ota_df["CGSf"]=np.where(ota_df["Type"]=="n",
                                     ota_df["W"]*CGSFn,
                                     ota_df["W"]*CGSFp)
ota_df["CGDf"]=np.where(ota_df["Type"]=="n",
                                     ota_df["W"]*CGDFn,
                                     ota_df["W"]*CGDFp)
ota_df["CBSj"]=np.where(ota_df["Type"]=="n",
                                    ota_df["AS"]*CJn+(ota_df["PS"]-ota_df["W"])*CJSWSTIn+ota_df["W"]*CJSWGATn,
                                    ota_df["AS"]*CJp+(ota_df["PS"]-ota_df["W"])*CJSWSTIp+ota_df["W"]*CJSWGATp)
ota_df["CBDj"]=np.where(ota_df["Type"]=="n",
                                    ota_df["AD"]*CJn+(ota_df["PD"]-ota_df["W"])*CJSWSTIn+ota_df["W"]*CJSWGATn,
                                    ota_df["AD"]*CJp+(ota_df["PD"]-ota_df["W"])*CJSWSTIp+ota_df["W"]*CJSWGATp)
ota_df["CGS"]=ota_df["CGSi"]+ota_df["CGSo"]+ota_df["CGSf"]
ota_df["CGD"]=ota_df["CGDi"]+ota_df["CGDo"]+ota_df["CGDf"]
ota_df["CGB"]=ota_df["CGBi"]+ota_df["CGBo"]
ota_df["CBS"]=ota_df["CBSi"]+ota_df["CBSj"]
ota_df["CBD"]=ota_df["CBDi"]+ota_df["CBDj"]
#pd.set_option('display.float_format', '{:.2E}'.format)
#ota_df

if newDesign:
  with pd.ExcelWriter(excelFilename) as writer:
    ota_specs_df.to_excel(writer, sheet_name="Specs", index=False)
    ota_bias_df.to_excel(writer, sheet_name="Bias", index=False)
    ota_df.to_excel(writer, sheet_name="Transistors")

# Generate the table from dataframe
feature_list=["W","L","ID","Ispec","IC","VG-VT0","VDSsat"]
Nmos=len(transistor_list)
Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(ota_df.at[mos,feature])
  table.append(row)

# Scale data for proper units
for i in range(Nmos):
  for j in [1,2]:
    table[i][j]=table[i][j]/1e-6
  for j in [3,4]:
    table[i][j]=table[i][j]/1e-9
  for j in [6,7]:
    table[i][j]=table[i][j]/1e-3

Markdown(tabulate(
  table,
  headers=["Transistor","$W\\;[\\mu m]$","$L\\;[\\mu m]$","$I_D\\;[nA]$","$I_{{spec}}\\;[nA]$","$IC$","$V_G-V_{{T0}}\\;[mV]$","$V_{{DSsat}}\\;[mV]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center","center","center"),
  floatfmt=(".3f",".2f",".2f",".0f",".0f",".1f",".0f",".0f")
))
```

```{python}
#| label: tbl-transistor_info2
#| tbl-cap: Transistor small-signal and thermal noise parameters.

# Generate the table from dataframe
feature_list=["Gspec","Gms","Gm","Gds","gamman"]
Nmos=len(transistor_list)
Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(ota_df.at[mos,feature])
  table.append(row)

# Scale data for proper units
for i in range(Nmos):
  for j in [1,2,3]:
    table[i][j]=table[i][j]/1e-6
  for j in [4]:
    table[i][j]=table[i][j]/1e-9

Markdown(tabulate(
  table,
  headers=["Transistor","$G_{{spec}}\\;[\\mu A/V]$","$G_{{ms}}\\;[\\mu A/V]$","$G_m\\;[\\mu A/V]$","$G_{{ds}}\\;[nA/V]$","$\\gamma_n$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f",".3f",".3f")
))
```


# OTA Characteristics
In this section, we check whether the specs are achieved.

## Open-loop gain
We can calculate the various OTA features related to the open-loop transfer function, which are given in @tbl-ota_gain.

```{python}
#| label: tbl-ota_gain
#| tbl-cap: OTA gain variables.

Gm1=ota_df.at['M1a','Gm']
Gds3b=ota_df.at['M3b','Gds']
Gms7=ota_df.at['M7','Gms']
Gds7=ota_df.at['M7','Gds']
Gds2d=ota_df.at['M2d','Gds']
Gms4=ota_df.at['M4','Gms']
Gds4=ota_df.at['M4','Gds']
Go=Gds3b*Gds7/Gms7+Gds2d*Gds4/Gms4
Adc=Gm1/Go
AdcdBthe=20*log(Adc)
Co=CL+ota_df.at['M7','CGD']+ota_df.at['M7','CBD']+ota_df.at['M4','CGD']+ota_df.at['M4','CBD']
tau0=Co/Go
w0=1/tau0
f0=w0/(2*pi)
wu=Gm1/Co
GBWest=wu/(2*pi)
CGS2=ota_df.at['M2a','CGS']
CGB2=ota_df.at['M2a','CGB']
C2=2*(CGS2+CGB2)
Gm2=ota_df.at['M2a','Gm']
taup2=C2/Gm2
wp2=1/taup2
fp2=wp2/(2*np.pi)
CGS3=ota_df.at['M3a','CGS']
CGB3=ota_df.at['M3a','CGB']
C3=2*(CGS3+CGB3)
Gm3=ota_df.at['M3a','Gm']
taup3=C3/Gm3
wp3=1/taup3
fp3=wp3/(2*np.pi)
C4=C2
Gm4=Gm2
taup4=C4/Gm4
wp4=1/taup4
fp4=wp4/(2*np.pi)

table = [["$A_{dc}$",f'{AdcdBthe:.0f}',"$dB$"],
         ["$G_{m1}$",f'{Gm1/1e-6:.3f}',"$\\mu A/V$"],
         ["$G_{m2}$",f'{Gm2/1e-6:.3f}',"$\\mu A/V$"],
         ["$G_{m3}$",f'{Gm3/1e-6:.3f}',"$\\mu A/V$"],
         ["$f_0$",f'{f0:.3f}',"$Hz$"],
         ["$GBW$",f'{GBWest/1e6:.3f}',"$MHz$"],
         ["$f_{p2}$",f'{fp2/1e6:.3f}',"$MHz$"],
         ["$f_{p3}$",f'{fp3/1e6:.3f}',"$MHz$"],
         ["$f_{p4}$",f'{fp4/1e6:.3f}',"$MHz$"]
         ]
Markdown(tabulate(
  table,
  headers=["Symbol","Theoretical Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center")
))
```

```{python}
from scipy.optimize import fsolve

def Adm(s,Adc,tau0,taup2,taup3,taup4):
    A1=Adc/2/(1+s*tau0)
    A2=1/(1+s*taup4)+1/((1+s*taup2)*(1+s*taup3))
    return A1*A2

def fun(f):
    jw=1j*2*pi*f
    AmagdB=20*log(abs(Adm(jw,Adc,tau0,taup2,taup3,taup4)))
    return AmagdB

GBWguess=GBWest
GBWsol=fsolve(fun,GBWguess)
GBWthe=GBWsol[0]

```

The gain-bandwidth product from the specifications is repeated here

$GBW =$ `{python} f'{GBWspec/1e6:.3f}'` MHz (from spec).

The estimated value assuming that all the non-dominant poles are much higher than the $GBW$ is given by

$GBW_{est} =$ `{python} f'{GBWest/1e6:.3f}'` MHz (estimation).

The $GBW$ accounting for the effect of the additional non-dominant poles is given by

$GBW_{the} =$ `{python} f'{GBWthe/1e6:.3f}'` MHz (theory).

We see that there is only a small difference between $GBW_{est}$ and $GBW_{the}$, which confirms that the non-dominant poles are sufficiently far from $GBW$ as stated in @tbl-ota_gain.

We can now plot the gain response using the variables given in @tbl-ota_gain. It is shown in @fig-ota_tf_the.

```{python}
#| label: fig-ota_tf_the
#| fig-cap: "OTA theoretical transfer function."

import matplotlib.patches as mpatches
import matplotlib.ticker

def Adm(s,Adc,tau0,taup2,taup3,taup4):
    A1=Adc/2/(1+s*tau0)
    A2=1/(1+s*taup4)+1/((1+s*taup2)*(1+s*taup3))
    return A1*A2

Npts=101
logfmin=1
logfmax=8
fmin=pow(10,logfmin)
fmax=pow(10,logfmax)
#x=np.linspace(xmin,xmax,Npts,endpoint=True)
fthe=np.logspace(logfmin,logfmax,Npts,endpoint=True,base=10.0)

AmagdBthe=np.zeros(Npts)
Aphiradthe=np.zeros(Npts)
Aphidegthe=np.zeros(Npts)
for k in range(0,Npts):
    jw=1j*2*pi*fthe[k]
    AmagdBthe[k]=20*log(abs(Adm(jw,Adc,tau0,taup2,taup3,taup4)))
    Aphiradthe[k]=np.angle(Adm(jw,Adc,tau0,taup2,taup3,taup4))

Aphidegthe=np.unwrap(Aphiradthe)*180/pi

PGBWthe=np.angle(Adm(1j*2*pi*GBWthe,Adc,tau0,taup2,taup3,taup4),deg=True)
PMthe=180+PGBWthe

plt.style.use('plt_style_small.mplstyle')
params = {'figure.figsize': (5,5)}
plt.rcParams.update(params)

fig, axs = plt.subplots(2, sharex=True)
lw=1

axs[0].semilogx([fmin,GBWthe],[0,0],'k--', linewidth=lw)
axs[0].semilogx([GBWthe,GBWthe],[0,-60],'k--', linewidth=lw)
axs[0].semilogx(fthe,AmagdBthe,'r',label='Theory')
axs[0].set(xlim=(fmin,fmax), ylim=(-60,100), ylabel='$|A_{vd}|$ [dB]')
axs[0].set_yticks([-60,-40,-20,0,20,40,60,80,100])
#axs[0].legend(loc='best')
textstr1 = '\n'.join((
    f'$A_{{dc}} =$ {AdcdBthe:.1f} dB',
    f'$GBW =$ {GBWthe/1e6:.1f} GHz'))
axs[0].text(0.7, 0.93, textstr1, ha='left', va='top', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogx([fmin,GBWthe],[PGBWthe,PGBWthe],'k--', linewidth=lw)
axs[1].semilogx([GBWthe,GBWthe],[PGBWthe,0],'k--', linewidth=lw)
axs[1].semilogx(fthe,Aphidegthe,'b',label='Theory')
axs[1].set(ylim=(-180,0), xlabel='Frequency [Hz]', ylabel='$arg\\{A_{vd}\\}$ [deg]')
axs[1].set_xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
axs[1].set_yticks([-180,-135,-90,-45,0])
#axs[1].legend(loc='best')
arrow = mpatches.FancyArrowPatch((GBWthe, PGBWthe), (GBWthe, -180),
                                 arrowstyle='<|-|>', color="black", mutation_scale=15)
axs[1].add_patch(arrow)
axs[1].annotate(f'Phase margin = {PMthe:.0f}$^{{\\circ}}$ ', (0, 0.5), xycoords=arrow, ha='right', va='center', size=9)
plt.subplots_adjust(hspace=0.1)

plt.show()
```

## Input-referred noise
We can now compute all the parameters needed for the calculation of the OTA thermal noise excess factor and its input-referred thermal noise PSD and resistance. They are given in @tbl-thermal.

```{python}
#| label: tbl-thermal
#| tbl-cap: OTA thermal noise parameters.

from IPython.display import Markdown
from tabulate import tabulate
Gm1=ota_df.at['M1a','Gm']
Gm2=ota_df.at['M2a','Gm']
Gm3=ota_df.at['M3a','Gm']
gamman1=ota_df.at['M1a','gamman']
gamman2=ota_df.at['M2a','gamman']
gamman3=ota_df.at['M3a','gamman']
etath=2*gamman2/gamman1*Gm2/Gm1+gamman3/gamman1*Gm3/Gm1
gammanotathe=2*gamman1*(1+etath)
Rninththe=gammanotathe/Gm1
Sninththe=4*kT*Rninththe
SninthdBvthe=10*log(Sninththe)
table = [["$G_{m1}$",f'{Gm1/1e-6:.3f}',"$\\mu A/V$"],
         ["$G_{m2}$",f'{Gm2/1e-6:.3f}',"$\\mu A/V$"],
         ["$G_{m3}$",f'{Gm3/1e-6:.3f}',"$\\mu A/V$"],
         ["$G_{m1}/G_{m2}$",f'{Gm1/Gm2:.3f}',"-"],
         ["$G_{m1}/G_{m3}$",f'{Gm1/Gm3:.3f}',"-"],
         ["$\\gamma_{n1}$",f'{gamman1:.3f}',"-"],
         ["$\\gamma_{n2}$",f'{gamman2:.3f}',"-"],
         ["$\\gamma_{n3}$",f'{gamman3:.3f}',"-"],
         ["$\\eta_{th}$",f'{etath:.3f}',"-"],
         ["$\\gamma_{ota}$",f'{gammanotathe:.3f}',"-"],
         ["$R_{nt}$",f'{Rninththe/1e3:.3f}',"$k \\Omega$"],
         ["$S_{ninth}$",f'{Sninththe:.1e}',"$V^2/Hz$"],
         ["$\\sqrt{S_{ninth}}$",f'{sqrt(Sninththe)/1e-9:.3f}',"$nV/\\sqrt{Hz}$"],
         ["$10 \\cdot \\log(S_{ninth})$",f'{SninthdBvthe:.3f}',"$dBv/\\sqrt{Hz}$"]
         ]
Markdown(tabulate(
  table,
  headers=["Symbol","Theoretical Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center")
))
```

From the value of $\eta_{th} =$ `{python} f'{etath:.3f}'` in @tbl-thermal, we see that the current mirrors M~2a~-M~2b~-M~2c~-M~2d~ and M~3a~-M~3b~ contribute about equally to the OTA input-referred thermal noise PSD. The OTA thermal noise excess factor is therefore about twice that of the differential pair $2\,\gamma_{n1}$.

We can now compute all the parameters needed for the calculation of the input-referred flicker noise and the corner frequency. They are given in @tbl-flicker.

```{python}
#| label: tbl-flicker
#| tbl-cap: OTA flicker noise parameters.

from IPython.display import Markdown
from tabulate import tabulate
W1=ota_df.at['M1a','W']
L1=ota_df.at['M1a','L']
W2=ota_df.at['M2a','W']
L2=ota_df.at['M2a','L']
W3=ota_df.at['M3a','W']
L3=ota_df.at['M3a','L']
W1eff=W1+DWn
L1eff=L1+DLn
W2eff=W2+DWp
L2eff=L2+DLp
W3eff=W3+DWn
L3eff=L3+DLn
etafl=2*rhop/rhon*(Gm2/Gm1)**2*W1eff*L1eff/(W2eff*L2eff)+(Gm3/Gm1)**2*W1eff*L1eff/(W3eff*L3eff)
Rnfl1Hz=2*rhon/(W1eff*L1eff)*(1+etafl)
Sfl1Hz=4*kT*Rnfl1Hz
Sninfl1HzdBv=10*log(Sfl1Hz)
fkthe=2*rhon/(W1eff*L1eff*Rninththe)*(1+etafl)
table = [["$(G_{m1}/G_{m2})^2$",f'{(Gm1/Gm2)**2:.1f}',"-"],
         ["$(G_{m1}/G_{m3})^2$",f'{(Gm1/Gm3)**2:.1f}',"-"],
         ["$\\rho_p/\\rho_n$",f'{rhop/rhon:.1f}',"-"],
         ["$\\frac{{W_1 \\cdot L_1}}{{W_2 \\cdot L_2}}$",f'{W1eff*L1eff/(W2eff*L2eff):.1f}',"-"],
         ["$\\frac{{W_1 \\cdot L_1}}{{W_3 \\cdot L_3}}$",f'{W1eff*L1eff/(W3eff*L3eff):.1f}',"-"],
         ["$\\eta_{fl}$",f'{etafl:.3f}',"-"],
         ["$\\sqrt{{S_{{ninfl}}(1\\,Hz)}}$",f'{sqrt(Sfl1Hz)/1e-6:.1f}',"$\\mu V/\\sqrt{{Hz}}$"],
         ["$10 \\cdot \\log(S_{{ninfl}}(1\\,Hz))$",f'{Sninfl1HzdBv:.1f}',"$dBv/\\sqrt{{Hz}}$"],
         ["$f_k$",f'{fkthe/1e3:.1f}',"$kHz$"]
         ]
Markdown(tabulate(
  table,
  headers=["Symbol","Theoretical Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center")
))
```

Similarly to thermal noise, from the value of $\eta_{fl} =$ `{python} f'{etafl:.3f}'` in @tbl-flicker, we see that the current mirrors M~2a~-M~2b~-M~2c~-M~2d~ and M~3a~-M~3b~ contribute about equally to the OTA input-referred flicker noise PSD, despite the large $\rho_p/\rho_n =$ `{python} f'{rhop/rhon:.3f}'` ratio and the smaller area of the current mirrors compared to the differential pair. This is achieved because of the high gains $(G_{m1}/G_{m2})^2 =$ `{python} f'{(Gm1/Gm2)**2:.1f}'` and $(G_{m1}/G_{m3})^2 =$ `{python} f'{(Gm1/Gm3)**2:.1f}'`.

We can plot the input-referred noise PSD which is shown in @fig-ota_noise_the. The corner frequency is estimated at $f_k =$ `{python} f'{fkthe/1e3:.1f}'` $kHz$.

```{python}
#| label: fig-ota_noise_the
#| fig-cap: "OTA theoretical input-referred noise PSD."

def Snflicker(f,S0,fk):
    return(S0*fk/f)

def Sntot(f,S0,fk):
    return(S0*(1+fk/f))

Npts=101
logfmin=1
logfmax=8
fmin=pow(10,logfmin)
fmax=pow(10,logfmax)
fthe=np.logspace(logfmin,logfmax,Npts,endpoint=True,base=10.0)

S0=4*kT*Rninththe
S0dBvthe=10*log(S0)

Sninththe=np.zeros(Npts)
Sninflthe=np.zeros(Npts)
Sninthe=np.zeros(Npts)
SninthdBvthe=np.zeros(Npts)
SninfldBvthe=np.zeros(Npts)
SnindBvthe=np.zeros(Npts)

for k in range(0,Npts):
    Sninththe[k]=S0
    Sninflthe[k]=Snflicker(fthe[k],S0,fkthe)
    Sninthe[k]=Sntot(fthe[k],S0,fkthe)
    SninthdBvthe[k]=10*log(Sninththe[k])
    SninfldBvthe[k]=10*log(Sninflthe[k])
    SnindBvthe[k]=10*log(Sninthe[k])

plt.style.use('plt_style_small.mplstyle')
plt.semilogx(fthe,SninthdBvthe,'b--',label='Thermal')
plt.semilogx(fthe,SninfldBvthe,'g--',label='Flicker')
plt.semilogx(fthe,SnindBvthe,'r',label='Total')
plt.xlim(fmin,fmax)
plt.xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-150,-100)
plt.yticks(np.arange(-150,-90,10))
plt.ylabel('Input Noise PSD $[dBv/\\sqrt{Hz}]$')
plt.legend(loc='center right', fontsize=9)
textstr = '\n'.join((
    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$',
    f'$f_k =$ {fkthe/1e3:.1f} kHz'))
plt.text(0.5, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
# saveFigures(savePath, 'Input_referred_noise')
plt.show()
```

## Input-referred offset voltage
The variance of the input-referred offset for $A_1=A_2=A_3=1$ is given by \eqref{eqn:vos} which can be rewritten as
\begin{equation}
  \sigma_{V_{os}}^2 = \sigma_{V_T}^2 + \sigma_{\beta}^2
\end{equation}
where
\begin{equation}
  \sigma_{V_T}^2 = \sigma_{V_{T1}}^2 \cdot (1 + \xi_{V_T})
\end{equation}
and
\begin{equation}
  \sigma_{\beta}^2 = \left(\frac{I_b}{G_{m1}}\right)^2 \cdot \sigma_{\beta_1}^2 \cdot (1 + \xi_{\beta}).
\end{equation}
$\xi_{V_T}$ represents the $V_T$-mismatch contributions to the input-referred offset of the current mirrors relative to that of the differential pair. It is given by \eqref{eqn:xivt2} which is repeated here
\begin{equation}
  \xi_{V_T} = 2\left(\frac{G_{m2}}{A_1\,G_{m1}}\right)^2 \cdot \left(\frac{A_{VTp}}{A_{VTn}}\right)^2 \cdot \frac{W_1 L_1}{W_2 L_2} + \left(\frac{G_{m3}}{G_{m1}}\right)^2 \cdot \frac{W_1 L_1}{W_3 L_3}
\end{equation}
and $\xi_{\beta}$ represents the $\beta$-mismatch contributions to the input-referred offset of the current mirrors relative to that of the differential pair. It is given by \eqref{eqn:xibeta2} which is repeated below
\begin{equation}
  \xi_{\beta} = 2\left(\frac{A_{\beta p}}{A_{\beta n}}\right)^2 \cdot \frac{W_1 L_1}{W_2 L_2} + \frac{1}{A_1^2} \cdot \frac{W_1 L_1}{W_3 L_3}.
\end{equation}
with
\begin{align}
  \sigma_{V_{T1}}^2 &= \frac{A_{VTn}^2}{W_1 L_1},\\
  \sigma_{V_{T2}}^2 &= \frac{A_{VTp}^2}{W_2 L_2},\\
  \sigma_{V_{T3}}^2 &= \frac{A_{VTn}^2}{W_3 L_3},
\end{align}
and
\begin{align}
  \sigma_{\beta 1}^2 &= \frac{A_{\beta n}^2}{W_1 L_1},\\
  \sigma_{\beta 2}^2 &= \frac{A_{\beta p}^2}{W_2 L_2},\\
  \sigma_{\beta 3}^2 &= \frac{A_{\beta n}^2}{W_3 L_3}.
\end{align}

The parameter for calculating the standard deviation of the input-referred offset voltage are given in @tbl-offset.

```{python}
#| label: tbl-offset
#| tbl-cap: OTA input-referred offset parameters.

from IPython.display import Markdown
from tabulate import tabulate
A1=1
sigma2vt1=AVTn**2/(W1*L1)
sigma2vt2=AVTp**2/(W2*L2)
sigma2vt3=AVTn**2/(W3*L3)
sigma2beta1=Abetan**2/(W1*L1)
sigma2beta2=Abetap**2/(W2*L2)
sigma2beta3=Abetan**2/(W3*L3)
xivt=2*(Gm2/Gm1)**2*(AVTp/AVTn)**2*(W1*L1)/(W2*L2)+(Gm3/(A1*Gm1))**2*(W1*L1)/(W3*L3)
xibeta=2*(Abetap/Abetan)**2*(W1*L1)/(W2*L2)+1/A1**2*(W1*L1)/(W3*L3)
sigma2vt=sigma2vt1*(1+xivt)
sigma2beta=(Ib/Gm1)**2*sigma2beta1*(1+xibeta)
sigma2Vos=sigma2vt+sigma2beta
sigmaVos=sqrt(sigma2Vos)
table = [["$\\sigma_{{VT1}}$",f'{sqrt(sigma2vt1)/1e-3:.3f}',"$mV$"],
         ["$\\sigma_{{VT2}}$",f'{sqrt(sigma2vt2)/1e-3:.3f}',"$mV$"],
         ["$\\sigma_{{VT3}}$",f'{sqrt(sigma2vt3)/1e-3:.3f}',"$mV$"],
         ["$\\sigma_{{\\beta1}}$",f'{sqrt(sigma2beta1)*100:.1f}',"$\\%$"],
         ["$\\sigma_{{\\beta2}}$",f'{sqrt(sigma2beta2)*100:.1f}',"$\\%$"],
         ["$\\sigma_{{\\beta3}}$",f'{sqrt(sigma2beta3)*100:.1f}',"$\\%$"],
         ["$\\xi_{{VT}}$",f'{xivt:.3f}',"-"],
         ["$\\xi_{{\\beta}}$",f'{xibeta:.3f}',"-"],
         ["$\\sigma_{{VT}}^2$",f'{sigma2vt/1e-6:.3f}',"$mV^2$"],
         ["$\\sigma_{{VT}}$",f'{sqrt(sigma2vt)/1e-3:.3f}',"$mV$"],
         ["$\\sigma_{{\\beta}}^2$",f'{sigma2beta/1e-6:.1f}',"$mV^2$"],
         ["$\\sigma_{{\\beta}}$",f'{sqrt(sigma2beta)/1e-3:.1f}',"$mV$"],
         ["$\\sigma_{{Vos}}$",f'{sigmaVos/1e-3:.3f}',"$mV$"]
         ]
Markdown(tabulate(
  table,
  headers=["Symbol","Theoretical Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center")
))
```

From @tbl-offset, we see that the $\beta$-mismatch is negligible and that the input-referred offset voltage is dominated by the contribution of the $V_T$-mismatch from the differential pair.

## Current and power consumption
```{python}
Itotmin=4*n0n*UT*CL*2*pi*GBWspec
Itot=4*Ib
```

The total current consumption, ignoring the current drawn by M~5a~, is $I_{tot} = (2+A_1+A_3) \cdot I_b$. Assuming the input differential pait M~1a~-M~1b~ is biased in weak inversion, the bias current is directly related to the gain-bandwidth product $GBW$ according to
\begin{equation}
  I_b \cong n U_T \cdot \frac{C_L}{A_3} \cdot GBW.
\end{equation}
The minimum total current consumption can then be estimated as
\begin{equation}
  I_{tot,min} \cong \frac{2+A_1+A_3}{A_3} \cdot n U_T \cdot C_L \cdot GBW.
\end{equation}
The bias current and the total current are proportional to the gain-bandwidth product $GBW$ and the load capacitance $C_L$. In the case $A_1=A_2=A_3=1$, we have

$I_{tot,min} \cong 4 \cdot n U_T \cdot C_L \cdot GBW =$ `{python} f'{Itotmin/1e-9:.0f}'` $nA$.

The actual current consumption accounting for some margin taken on the $GBW$ is given by

$I_{tot} = 4 I_b =$ `{python} f'{Itot/1e-6:.2f}'` $\mu A$ which is `{python} f'{Itot/Itotmin:.3f}'` larger than the absolute minimum current consumption. This larger current consumption is mostly due to the parasitic capacitances at the output which add to the exsiting load capacitance and require a larger transconductance and hence a larger current to achive the same $GBW$.

The above design will now be checked against simulations.


# Simulation results from ngspice
The theoretical results can be validated with the results obtained from simulations performed with ngspice. In order to run the simulations you need to have ngspice correctly installed. Please refer to the installation instructions.

::: {.callout-note}
The simulations are performed with the PSP 103.6 compact model @bib:psp103.6:2017 using the parameters from the IHP open source PDK @bib:ihp:2025. For ngspice, we use the Verilog-A implementation given in the IHP package @bib:ihp:2025 and compiled the OSDI file with OpenVAF @bib:openvaf:2025 to run with ngspice @bib:dwarning:2024. In addition to the PSP user manual @bib:psp103.6:2017 a documentation of PSP and other MOSFET compact models and their parameter extraction can be found in @bib:iccap:2008.
:::

## Operating point
We first write the parameter file for this specific design for running the ngspice simulations.
Before running the AC and NOISE simulations, we first need to check the quiescent voltages and currents and the operating points of all transistors by running a .OP simulation.

```{python}
#| label: tbl-ng_openloop_voltages1
#| tbl-cap: OTA node voltages with the OTA in open-loop without offset correction.

simtype = ".op"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationVoltages = simulationPath + fileName + ".ic"
simulationData = simulationPath + fileName + ".dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + "1.ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + "1.dat"

W1=ota_df.at['M1a','W']
L1=ota_df.at['M1a','L']
AS1=ota_df.at['M1a','AS']
PS1=ota_df.at['M1a','PS']
AD1=ota_df.at['M1a','AD']
PD1=ota_df.at['M1a','PD']
W2=ota_df.at['M2a','W']
L2=ota_df.at['M2a','L']
AS2=ota_df.at['M2a','AS']
PS2=ota_df.at['M2a','PS']
AD2=ota_df.at['M2a','AD']
PD2=ota_df.at['M2a','PD']
W3=ota_df.at['M3a','W']
L3=ota_df.at['M3a','L']
AS3=ota_df.at['M3a','AS']
PS3=ota_df.at['M3a','PS']
AD3=ota_df.at['M3a','AD']
PD3=ota_df.at['M3a','PD']
W4=ota_df.at['M4','W']
L4=ota_df.at['M4','L']
AS4=ota_df.at['M4','AS']
PS4=ota_df.at['M4','PS']
AD4=ota_df.at['M4','AD']
PD4=ota_df.at['M4','PD']
W5=ota_df.at['M5a','W']
L5=ota_df.at['M5a','L']
AS5=ota_df.at['M5a','AS']
PS5=ota_df.at['M5a','PS']
AD5=ota_df.at['M5a','AD']
PD5=ota_df.at['M5a','PD']
W7=ota_df.at['M7','W']
L7=ota_df.at['M7','L']
AS7=ota_df.at['M7','AS']
PS7=ota_df.at['M7','PS']
AD7=ota_df.at['M7','AD']
PD7=ota_df.at['M7','PD']

Vic=0.6
Vos=0

if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Vb1={Vb1:.1f} Vb2={Vb2:.1f} Ib={Ib/1e-9:.0f}n',
    f'.param CL={CL/1e-12:.0f}p',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u AS1={AS1:.3e} PS1={PS1:.3e} AD1={AD1:.3e} PD1={PD1:.3e}',
    f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u AS2={AS2:.3e} PS2={PS2:.3e} AD2={AD2:.3e} PD2={PD2:.3e}',
    f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u AS3={AS3:.3e} PS3={PS3:.3e} AD3={AD3:.3e} PD3={PD3:.3e}',
    f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u AS4={AS4:.3e} PS4={PS4:.3e} AD4={AD4:.3e} PD4={PD4:.3e}',
    f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u AS5={AS5:.3e} PS5={PS5:.3e} AD5={AD5:.3e} PD5={PD5:.3e}',
    f'.param W7={W7/1e-6:.2f}u L7={L7/1e-6:.2f}u AS7={AS7:.3e} PS7={PS7:.3e} AD7={AD7:.3e} PD7={PD7:.3e}'
    ))
  #print(paramstr)
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  #print('Starting ngspice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)
  shutil.copy2(simulationData, ngspiceDataFile)

nodeList=["vdd","vb1","vb2","inp","inn","out","ic","id","1","2","3","4","5","6","8"]
v_df=pd.DataFrame(index=nodeList)
Nnodes=len(nodeList)
for k in range(0,Nnodes):
  nodeName=nodeList[k]
  regexp = re.compile(r'v\(' + nodeName + r'\)' + refloat)
  with open(ngspiceNodeVoltageFile) as f:
    for line in f:
      match = re.search(regexp, line)
      if match:
        v_df.at[nodeName, 'Voltage']=float(match.group(1))

Voutq=v_df.loc['out','Voltage']
#pd.set_option('display.float_format', '{:.2f}'.format)
#v_df

Markdown( 
  tabulate(v_df,
  showindex=True,
  headers=["Node","Voltage"],
  numalign="center",
  stralign="center",
  colalign=("center","center")
))
```

From the node voltages shown in @tbl-ng_openloop_voltages1, we see that the output voltage $V_{outq} =$ `{python} f'{Voutq/1e-3:.0f}'` $mV$ is too low and is pushing M~7~ and M~3b~ out of saturation. This is due to the current mismatch in M~2c~ and M~2d~ and between M~3a~ and M~3b~ due to different drain voltages and finite output conductances leading to a different current flowing in M~2d~ and M~4~ compared to that flowing in M~3b~ and M~7~. Even if the current difference is very small, it results in a large voltage debiasing at the output because of the high output resistance provided by the cascode stages.

Therefore simulating the open-loop gain for high gain amplifiers is not easy to perform without closing the loop. There are basically two approaches to simulate the open-loop gain for high-gain amplifiers:

1) Imposing a DC offset voltage to the amplifier in open-loop configuration that brings the output voltage back to normal (for example equal to the input common-mode voltage) or
2) Simulating the closed-loop gain (for example in voltage follower mode with a feedback gain of 1) and extracting the open-loop gain from the closed loop gain according to

\begin{equation}
  A_{open\textsf{-}loop}(\omega)= \frac{A_{closed\textsf{-}loop}(\omega)}{1 - A_{closed\textsf{-}loop}(\omega)},
\end{equation}
where $A_{closed\textsf{-}loop}(\omega)$ is the simulated closed-loop transfer function and $A_{open\textsf{-}loop}(\omega)$, the computed open-loop transfer function. The above relation assumes that the open-loop DC gain is large enough for the input-referred offset voltage to be ignored.

The input-referred offset voltage can be extracted from the closed-loop voltage follower circuit as
\begin{equation}
  V_{os} = V_{in} - \left(1+\frac{1}{A}\right) \cdot V_{out} \cong V_{in} - V_{out} \quad \textsf{for $A \gg 1$},
\end{equation}
where $A \triangleq A_{open\textsf{-}loop}(0)$ is the open-loop DC gain which can be assumed to be much larger than 1. This means that, provided the DC open-loop gain is sufficiently large, the offset voltage can be measured at the amplifier differential input after imposing the proper input common-mode voltage $V_{ic}$.

We can now simulate the OTA in closed-loop as a voltage follower.

```{python}
#| label: tbl-ng_closedloop_voltages
#| tbl-cap: OTA node voltages with the OTA in voltage follower configuration.

simtype = ".op"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationVoltages = simulationPath + fileName + ".ic"
simulationData = simulationPath + fileName + ".dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + ".ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + ".dat"

if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Vb1={Vb1:.1f} Vb2={Vb2:.1f} Ib={Ib/1e-9:.0f}n',
    f'.param CL={CL/1e-12:.0f}p',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u AS1={AS1:.3e} PS1={PS1:.3e} AD1={AD1:.3e} PD1={PD1:.3e}',
    f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u AS2={AS2:.3e} PS2={PS2:.3e} AD2={AD2:.3e} PD2={PD2:.3e}',
    f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u AS3={AS3:.3e} PS3={PS3:.3e} AD3={AD3:.3e} PD3={PD3:.3e}',
    f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u AS4={AS4:.3e} PS4={PS4:.3e} AD4={AD4:.3e} PD4={PD4:.3e}',
    f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u AS5={AS5:.3e} PS5={PS5:.3e} AD5={AD5:.3e} PD5={PD5:.3e}',
    f'.param W7={W7/1e-6:.2f}u L7={L7/1e-6:.2f}u AS7={AS7:.3e} PS7={PS7:.3e} AD7={AD7:.3e} PD7={PD7:.3e}'
    ))
  #print(paramstr)
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  #print('Starting ngspice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)
  shutil.copy2(simulationData, ngspiceDataFile)

nodeList=["vdd","vb1","vb2","inp","out","1","2","3","4","5","6","8"]
v_df=pd.DataFrame(index=nodeList)
Nnodes=len(nodeList)
for k in range(0,Nnodes):
  nodeName=nodeList[k]
  regexp = re.compile(r'v\(' + nodeName + r'\)' + refloat)
  with open(ngspiceNodeVoltageFile) as f:
    for line in f:
      match = re.search(regexp, line)
      if match:
        v_df.at[nodeName, 'Voltage']=float(match.group(1))

Voutq=v_df.loc['out','Voltage']
Vos=v_df.loc['inp','Voltage']-v_df.loc['out','Voltage']
#pd.set_option('display.float_format', '{:.6f}'.format)
#v_df

Markdown( 
  tabulate(v_df,
  showindex=True,
  headers=["Node","Voltage"],
  numalign="center",
  stralign="center",
  colalign=("center","center")
))
```

From the node voltages of the OTA in voltage follower configuration shown in @tbl-ng_closedloop_voltages, we see that now the ouput voltage $V_{outq} =$ `{python} f'{Voutq/1e-3:.0f}'` $mV$ is very close to the input voltage that has been set to $V_{ic} =$ `{python} f'{Vic/1e-3:.0f}'` $mV$. We can then extract the corresponding offset voltage $V_{os} \cong V_{in} - V_{out} =$ `{python} f'{Vos/1e-6:.3f}'` $\mu V$.

We can now apply this offset voltage to the open-loop operating point point simulation.

```{python}
#| label: tbl-ng_openloop_voltages2
#| tbl-cap: OTA node voltages with the OTA in open-loop including offset correction.

from IPython.display import Markdown
from tabulate import tabulate

simtype = ".op"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationVoltages = simulationPath + fileName + ".ic"
simulationData = simulationPath + fileName + ".dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + "2.ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + "2.dat"

#print('Starting ngspice simulation...\n')
if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Vb1={Vb1:.1f} Vb2={Vb2:.1f} Ib={Ib/1e-9:.0f}n',
    f'.param CL={CL/1e-12:.0f}p',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u AS1={AS1:.3e} PS1={PS1:.3e} AD1={AD1:.3e} PD1={PD1:.3e}',
    f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u AS2={AS2:.3e} PS2={PS2:.3e} AD2={AD2:.3e} PD2={PD2:.3e}',
    f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u AS3={AS3:.3e} PS3={PS3:.3e} AD3={AD3:.3e} PD3={PD3:.3e}',
    f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u AS4={AS4:.3e} PS4={PS4:.3e} AD4={AD4:.3e} PD4={PD4:.3e}',
    f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u AS5={AS5:.3e} PS5={PS5:.3e} AD5={AD5:.3e} PD5={PD5:.3e}',
    f'.param W7={W7/1e-6:.2f}u L7={L7/1e-6:.2f}u AS7={AS7:.3e} PS7={PS7:.3e} AD7={AD7:.3e} PD7={PD7:.3e}'
    ))
  #print(paramstr)
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)
  shutil.copy2(simulationData, ngspiceDataFile)

nodeList=["vdd","vb1","vb2","inp","inn","out","ic","id","1","2","3","4","5","6","8"]
v_df=pd.DataFrame(index=nodeList)

Nnodes=len(nodeList)
for k in range(0,Nnodes):
  nodeName=nodeList[k]
  regexp = re.compile(r'v\(' + nodeName + r'\)' + refloat)
  with open(ngspiceNodeVoltageFile) as f:
    for line in f:
      match = re.search(regexp, line)
      if match:
        v_df.at[nodeName, 'Voltage']=float(match.group(1))

Voutq=v_df.loc['out','Voltage']
#pd.set_option('display.float_format', '{:.6f}'.format)
#v_df

Markdown( 
  tabulate(v_df,
  showindex=True,
  headers=["Node","Voltage"],
  numalign="center",
  stralign="center",
  colalign=("center","center")
))
```

From the node voltages of the OTA in open-loop configuration shown in @tbl-ng_openloop_voltages2 after adding the offset voltage at the input, we see that now the ouput voltage $V_{outq} =$ `{python} f'{Voutq/1e-3:.0f}'` $mV$ of the open-loop circuit is sufficiently close to the common-mode input voltage $V_{ic} =$ `{python} f'{Vic/1e-3:.0f}'` $mV$.

The operating point information for all transistors are extracted from the ngspice .op file. The data is split into the large-signal operating informations in @tbl-ng_op1, the small-signal operating point informations in @tbl-ng_op2 and the noise operating point informations in @tbl-ng_op3.

We can compare the results of the .op file (for example the inversion coefficient $IC$) to the results of the design given in @tbl-transistor_info1. We observe that the values are close.

Similarly we can compare the small-signal parameters (for example the gate transconductance $G_m$) resulting from the .op file to the results of the design presented in @tbl-transistor_info2. Again, we see that they are reasonably close.

```{python}
#| label: tbl-ng_op1
#| tbl-cap: Operating point information extracted from ngspice .op file for each transistor.

df_mos=pd.read_table(ngspiceDataFile, sep=r'\s+', skiprows=[2,4,6,8,10,12,14,16,18,20,22], dtype=np.float64, engine='python')
df_mos=df_mos.rename(columns={'@n.x1a.nsg13_lv_nmos[weff]': 'Transistor',
                              '@n.x1a.Nsg13_lv_nmos[weff]': 'Weff', '@n.x1a.Nsg13_lv_nmos[leff]': 'Leff',
                              '@n.x1a.Nsg13_lv_nmos[ids]': 'ID',
                              '@n.x1a.Nsg13_lv_nmos[vgs]': 'VGS', '@n.x1a.Nsg13_lv_nmos[vds]': 'VDS', '@n.x1a.Nsg13_lv_nmos[vsb]': 'VSB',
                              '@n.x1a.Nsg13_lv_nmos[vgt]': 'VG-VT', '@n.x1a.Nsg13_lv_nmos[vdss]': 'VDsat',
                              '@n.x1a.Nsg13_lv_nmos[gm]': 'Gm', '@n.x1a.Nsg13_lv_nmos[gmb]': 'Gmb', '@n.x1a.Nsg13_lv_nmos[gds]': 'Gds',
                              '@n.x1a.Nsg13_lv_nmos[sid]': 'SIDth', '@n.x1a.Nsg13_lv_nmos[sfl]': 'SIDfl at 1Hz'})
df_mos['Transistor'] = df_mos['Transistor'].astype(str)

for k in range(Nmos):
  df_mos.at[k, 'Transistor'] = transistor_list[k]

df_mos.set_index('Transistor', inplace=True)
df_mos.rename_axis(index=None, inplace=True)
pd.set_option('display.float_format', '{:.2E}'.format)
#df_mos

feature_list=["ID","VGS","VDS","VSB","VG-VT","VDsat"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mos.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [1]:
    table[i][j]=table[i][j]/1e-9
  for j in [2,3,4,5,6]:
    table[i][j]=table[i][j]/1e-3

Markdown(tabulate(
  table,
  headers=["Transistor","$I_D\\;[nA]$","$V_{GS}\\;[mV]$","$V_{DS}\\;[mV]$","$V_{SB}\\;[mV]$","$V_{GS}-V_T\\;[mV]$","$V_{Dsat}\\;[mV]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center","center"),
  floatfmt=(".3f",".3f",".0f",".0f",".0f",".0f",".0f")
))
```

```{python}
#| label: tbl-ng_op2
#| tbl-cap: PSP small-signal operating point information extracted from ngspice .op file for each transistor.

feature_list=["Gm","Gmb","Gds"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mos.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [1,2]:
    table[i][j]=table[i][j]/1e-6
  for j in [3]:
    table[i][j]=table[i][j]/1e-9

Markdown(tabulate(
  table,
  headers=["Transistor","$G_m\\;[\\mu A/V]$","$G_{mb}\\;[\\mu A/V]$","$G_{ds}\\;[nA/V]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f")
))
```

```{python}
#| label: tbl-ng_op3
#| tbl-cap: PSP noise operating point information extracted from ngspice .op file for each transistor.

feature_list=["SIDth","SIDfl at 1Hz"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mos.at[mos,feature])
  table.append(row)

#for i in range(Nmos):
#  for j in [2]:
#    table[i][j]=table[i][j]/1e3
#  for j in [3]:
#    table[i][j]=table[i][j]/1e-9
#  for j in [4]:
#    table[i][j]=table[i][j]/1e-6

Markdown(tabulate(
  table,
  headers=["Transistor","$S_{ID,th}\\;[A^2/Hz]$","$S_{ID,fl}$ at 1Hz $[A^2/Hz]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center"),
  floatfmt=(".3e",".3e",".3e")
))
```

```{python}
#| label: tbl-ng_op4
#| tbl-cap: sEKV parameters calculated from the values extracted from the simulation.

transistor_info={
    "Type": ["n","n","p","p","p","p","n","n","p","n","n","n"]
}
#transistor_list=["M1a","M1b","M2a","M2b","M2c","M2d","M3a","M3b","M4","M5a","M5b","M7"]

df_mos_sekv=pd.DataFrame(transistor_info, index=transistor_list)

df_mos_sekv["Weff"]=df_mos["Weff"]
df_mos_sekv["Leff"]=df_mos["Leff"]
df_mos_sekv["Weff/Leff"]=df_mos["Weff"]/df_mos["Leff"]
df_mos_sekv["Ispec"]=np.where(df_mos_sekv["Type"]=="n",
                                     df_mos_sekv["Weff/Leff"]*Ispecsqn,
                                     df_mos_sekv["Weff/Leff"]*Ispecsqp)
df_mos_sekv["IC"]=df_mos["ID"]/df_mos_sekv["Ispec"]
df_mos_sekv["Gspec"]=df_mos_sekv["Ispec"]/UT
df_mos_sekv["n"]=df_mos["Gmb"]/df_mos["Gm"]+1
df_mos_sekv["Gm"]=df_mos["Gm"]
df_mos_sekv["Gms"]=df_mos_sekv["n"]*df_mos["Gm"]
df_mos_sekv["Gds"]=df_mos["Gds"]
df_mos_sekv["Vninth"]=sqrt(df_mos["SIDth"])/df_mos["Gm"]
df_mos_sekv["Rninth"]=df_mos["SIDth"]/(4*kT*df_mos["Gm"]**2)
df_mos_sekv["gamman"]=df_mos["Gm"]*df_mos_sekv["Rninth"]
df_mos_sekv["Vninfl at 1 Hz"]=sqrt(df_mos["SIDfl at 1Hz"])/df_mos["Gm"]
#df_mos_sekv

feature_list=["Weff","Leff","Weff/Leff","Ispec","IC"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mos_sekv.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [1,2,4]:
    table[i][j]=table[i][j]/1e-6

Markdown(tabulate(
  table,
  headers=["Transistor","$W_{eff}\\;[\\mu m]$","$L_{eff}\\;[\\mu m]$","$W_{eff}/L_{eff}$","$I_{spec}\\;[\\mu A]$","$IC$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f",".3f",".3f")
))
```

```{python}
#| label: tbl-ng_op5
#| tbl-cap: sEKV small-signal parameters calculated from the values extracted from the simulation.

feature_list=["Gspec","n","Gm","Gms","Gds"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mos_sekv.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [1,3,4]:
    table[i][j]=table[i][j]/1e-6
  for j in [5]:
    table[i][j]=table[i][j]/1e-9

Markdown(tabulate(
  table,
  headers=["Transistor","$G_{spec}\\;[\\mu A/V]$","$n$","$G_m\\;[\\mu A/V]$","$G_{ms}\\;[\\mu A/V]$","$G_{ds}\\;[nA/V]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f",".3f",".3f")
))
```

```{python}
#| label: tbl-ng_op6
#| tbl-cap: sEKV noise parameters calculated from the values extracted from the simulation.

feature_list=["Vninth","Rninth","gamman","Vninfl at 1 Hz"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mos_sekv.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [1,4]:
    table[i][j]=table[i][j]/1e-9
  for j in [2]:
    table[i][j]=table[i][j]/1e3

Markdown(tabulate(
  table,
  headers=["Transistor","$\\sqrt{S_{nin,th}}\\;[nV/\\sqrt{Hz}]$","$R_{nin,th}\\;[k\\Omega]$","$\\gamma_n\\;[-]$","$\\sqrt{S_{nin,fl}}\\;[nV/\\sqrt{Hz}]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f",".3f")
))
```

We can also check the bias voltages and operating region of each transistor which are given in @tbl-ng_bias.

```{python}
#| label: tbl-ng_bias
#| tbl-cap: Bias voltages and operating regions extracted from ngspice for each transistor.

VGB1a=v_df.loc['inp','Voltage']-v_df.loc['1','Voltage']
VGB1b=v_df.loc['inn','Voltage']-v_df.loc['1','Voltage']
VBG2a=v_df.loc['vdd','Voltage']-v_df.loc['2','Voltage']
VBG2b=v_df.loc['vdd','Voltage']-v_df.loc['4','Voltage']
VBG2c=v_df.loc['vdd','Voltage']-v_df.loc['2','Voltage']
VBG2d=v_df.loc['vdd','Voltage']-v_df.loc['6','Voltage']
VGB3a=v_df.loc['3','Voltage']
VGB3b=v_df.loc['3','Voltage']
VBG4=v_df.loc['vdd','Voltage']-v_df.loc['vb1','Voltage']
VGB5a=v_df.loc['8','Voltage']
VGB5b=v_df.loc['8','Voltage']
VGB7=v_df.loc['vb2','Voltage']

VSB1a=0
VSB1b=0
VBS2a=0
VBS2b=0
VBS2c=0
VBS2d=0
VSB3a=0
VSB3b=0
VBS4=v_df.loc['vdd','Voltage']-v_df.loc['6','Voltage']
VSB5a=0
VSB5b=0
VSB7=v_df.loc['5','Voltage']

VDB1a=v_df.loc['2','Voltage']-v_df.loc['1','Voltage']
VDB1b=v_df.loc['4','Voltage']-v_df.loc['1','Voltage']
VBD2a=v_df.loc['vdd','Voltage']-v_df.loc['2','Voltage']
VBD2b=v_df.loc['vdd','Voltage']-v_df.loc['4','Voltage']
VBD2c=v_df.loc['vdd','Voltage']-v_df.loc['3','Voltage']
VBD2d=v_df.loc['vdd','Voltage']-v_df.loc['6','Voltage']
VDB3a=v_df.loc['3','Voltage']
VDB3b=v_df.loc['5','Voltage']
VBD4=v_df.loc['vdd','Voltage']-v_df.loc['out','Voltage']
VDB5a=v_df.loc['8','Voltage']
VDB5b=v_df.loc['1','Voltage']
VDB7=v_df.loc['out','Voltage']

VDS1a=VDB1a-VSB1a
VDS1b=VDB1b-VSB1b
VSD2a=VBD2a-VBS2a
VSD2b=VBD2b-VBS2b
VSD2c=VBD2c-VBS2c
VSD2d=VBD2d-VBS2d
VDS3a=VDB3a-VSB3a
VDS3b=VDB3b-VSB3b
VSD4=VBD4-VBS4
VDS5a=VDB5a-VSB5a
VDS5b=VDB5b-VSB5b
VDS7=VDB7-VSB7

ID1a=df_mos.loc['M1a','ID']
ID1b=df_mos.loc['M1b','ID']
ID2a=df_mos.loc['M2a','ID']
ID2b=df_mos.loc['M2b','ID']
ID2c=df_mos.loc['M2c','ID']
ID2d=df_mos.loc['M2d','ID']
ID3a=df_mos.loc['M3a','ID']
ID3b=df_mos.loc['M3b','ID']
ID4=df_mos.loc['M4','ID']
ID5a=df_mos.loc['M5a','ID']
ID5b=df_mos.loc['M5b','ID']
ID7=df_mos.loc['M7','ID']

IC1a=df_mos_sekv.loc['M1a','IC']
IC1b=df_mos_sekv.loc['M1b','IC']
IC2a=df_mos_sekv.loc['M2a','IC']
IC2b=df_mos_sekv.loc['M2b','IC']
IC2c=df_mos_sekv.loc['M2c','IC']
IC2d=df_mos_sekv.loc['M2d','IC']
IC3a=df_mos_sekv.loc['M3a','IC']
IC3b=df_mos_sekv.loc['M3b','IC']
IC4=df_mos_sekv.loc['M4','IC']
IC5a=df_mos_sekv.loc['M5a','IC']
IC5b=df_mos_sekv.loc['M5b','IC']
IC7=df_mos_sekv.loc['M7','IC']

VDsat1a=df_mos.loc['M1a','VDsat']
VDsat1b=df_mos.loc['M1b','VDsat']
VDsat2a=df_mos.loc['M2a','VDsat']
VDsat2b=df_mos.loc['M2b','VDsat']
VDsat2c=df_mos.loc['M2c','VDsat']
VDsat2d=df_mos.loc['M2d','VDsat']
VDsat3a=df_mos.loc['M3a','VDsat']
VDsat3b=df_mos.loc['M3b','VDsat']
VDsat4=df_mos.loc['M4','VDsat']
VDsat5a=df_mos.loc['M5a','VDsat']
VDsat5b=df_mos.loc['M5b','VDsat']
VDsat7=df_mos.loc['M7','VDsat']

df_mosop={
  "Type": ["n","n","p","p","p","p","n","n","p","n","n","p"],
  "Function": ["DP","DP","CM","CM","CM","CM","CM","CM","CA","CM","CM","CA"],
  "ID": [ID1a,ID1b,ID2a,ID2b,ID2c,ID2d,ID3a,ID3b,ID4,ID5a,ID5b,ID7],
  "IC": [IC1a,IC1b,IC2a,IC2b,IC2c,IC2d,IC3a,IC3b,IC4,IC5a,IC5b,IC7],
  "VG": [VGB1a,VGB1b,VBG2a,VBG2b,VBG2c,VBG2d,VGB3a,VGB3b,VBG4,VGB5a,VGB5b,VGB7],
  "VS": [VSB1a,VSB1b,VBS2a,VBS2b,VBS2c,VBS2d,VSB3a,VSB3b,VBS4,VSB5a,VSB5b,VSB7],
  "VD": [VDB1a,VDB1b,VBD2a,VBD2b,VBD2c,VBD2d,VDB3a,VDB3b,VBD4,VDB5a,VDB5b,VDB7],
  "VDS": [VDS1a,VDS1b,VSD2a,VSD2b,VSD2c,VSD2d,VDS3a,VDS3b,VSD4,VDS5a,VDS5b,VDS7],
  "VDsat": [VDsat1a,VDsat1b,VDsat2a,VDsat2b,VDsat2c,VDsat2d,VDsat3a,VDsat3b,VDsat4,VDsat5a,VDsat5b,VDsat7]
  }

df_mosop=pd.DataFrame(df_mosop, index=transistor_list)
df_mosop["Region"]=np.where(df_mosop["IC"]<0.1,
                                     "WI",
                                     np.where(df_mosop["IC"]<10,
                                     "MI",
                                     "SI"))
df_mosop["Saturation"]=np.where(df_mosop["VDS"]>df_mosop["VDsat"],
                                     "sat",
                                     "lin")
#pd.set_option('display.float_format', '{:.3E}'.format)
#df_mosop

feature_list=["Type","Function","VG","VS","VD","VDS","VDsat","Region","Saturation"]
#Nmos=len(transistor_list)
Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mosop.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [6,7]:
    table[i][j]=table[i][j]/1e-3

Markdown(tabulate(
  table,
  headers=["Trans.","Type","Funct.","$V_G\\;[V]$","$V_S\\;[V]$","$V_D\\;[V]$","$V_{DS}\\;[mV]$","$V_{DSsat}\\;[mV]$","Reg.","Sat."],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center","center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f",".3f",".3f",".0f",".0f",".3f",".3f")
))
```

From @tbl-ng_bias, we see that all transistors are biased in saturation. The operating points look fine. We can now proceed with the simulation of the open-loop large-signal transfer characteristic.

## Large-signal differential transfer characteristic
We now simulate the DC differential transfer characteristic. We can then check the systematic offset voltage that was extracted above. The simulation of the large-signal input-output characteristic is presented in @fig-ng_large_signal.

```{python}
#| label: fig-ng_large_signal
#| fig-cap: "Simulated large-signal input-output characteristic."

simtype = ".dc"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + "1.dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + "1.log"

Vidmin=-0.6
Vidmax=0.6
dVid=2e-3

if newSim:
  simpar = '\n'.join((
    f'.csparam Vidmin={Vidmin:.3e}',
    f'.csparam Vidmax={Vidmax:.3e}',
    f'.csparam dVid={dVid:.3e}'
  ))
  simparFile = simulationPath + "simulation.dc.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

Vidsim=df_sim['v-sweep'].to_numpy()
Voutsim=df_sim['Vout'].to_numpy()

regexp = re.compile(r'voutmax' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutmax=float(match.group(1))

regexp = re.compile(r'voutmin' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutmin=float(match.group(1))

Vswing=Voutmax-Voutmin

lw=1
plt.style.use('plt_style_small.mplstyle')
plt.plot([Vidmin/1e-3,0],[Voutq,Voutq],'k--', linewidth=lw)
plt.plot([0,0],[0,Voutq],'k--', linewidth=lw)
plt.plot([Vidmin/1e-3,Vidmax/1e-3],[Voutmax,Voutmax],'k--', linewidth=lw)
plt.plot([Vidmin/1e-3,Vidmax/1e-3],[Voutmin,Voutmin],'k--', linewidth=lw)
plt.plot(Vidsim,Voutsim,'r')
plt.xlim(Vidmin,Vidmax)
#plt.xticks(np.arange(-0.6,0,0.3))
plt.xlabel('$V_{id}$ [$V$]')
plt.ylim(0,1.2)
plt.yticks(np.arange(0,1.4,0.2))
plt.ylabel('$V_{out}$ [V]')
#plt.legend(loc='best')
textstr = '\n'.join((
  f'$V_{{DD}} =$ {VDD:.1f} V',
  f'$V_{{ic}} =$ {Vic:.1f} V',
  f'$V_{{outq}} =$ {Voutq:.3f} V',
  f'$V_{{outmax}} =$ {Voutmax:.3f} V',
  f'$V_{{outmin}} =$ {Voutmin:.3f} V',
  f'$V_{{swing}} =$ {Vswing:.2f} V'))
plt.text(0.65, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, 'Vout_Vid')
plt.show()
```

We can now zoom into the high gain region in order to extract a more accurate value of the offset voltage and the output swing. The simulation results are presented in @fig-ng_large_signal_zoom.

```{python}
#| label: fig-ng_large_signal_zoom
#| fig-cap: "Zoom of the simulated large-signal input-output characteristic in the gain region."

simtype = ".dc"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + "2.dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + "2.log"

Vidmin=110e-6
Vidmax=120e-6
#Vidmin=round(1e5*Vos)/1e5-1e-5
#Vidmax=Vidmin+2e-5
dVid=0.01e-6

if newSim:
  simpar = '\n'.join((
    f'.csparam Vidmin={Vidmin:.3e}',
    f'.csparam Vidmax={Vidmax:.3e}',
    f'.csparam dVid={dVid:.3e}'
  ))
  simparFile = simulationPath + "simulation.dc.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

Vidsim=df_sim['v-sweep'].to_numpy()
Voutsim=df_sim['Vout'].to_numpy()

regexp = re.compile(r'voutmax' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutmax=float(match.group(1))

regexp = re.compile(r'voutmin' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutmin=float(match.group(1))

regexp = re.compile(r'vos' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Vos=float(match.group(1))

Voutq=0.6
Vswing=Voutmax-Voutmin

lw=1
plt.style.use('plt_style_small.mplstyle')
plt.plot([Vidmin/1e-6,Vos/1e-6],[Vic,Vic],'k--', linewidth=lw)
plt.plot([Vos/1e-6,Vos/1e-6],[0.4,Vic],'k--', linewidth=lw)
plt.plot([Vidmin/1e-3,Vidmax/1e-3],[Voutmax,Voutmax],'k--', linewidth=lw)
plt.plot([Vidmin/1e-3,Vidmax/1e-3],[Voutmin,Voutmin],'k--', linewidth=lw)
plt.plot(Vidsim/1e-6,Voutsim,'r')
plt.xlim(Vidmin/1e-6,Vidmax/1e-6)
#plt.xticks(np.arange(54,76,2))
plt.xlabel('$V_{id}\\;[\\mu V]$')
plt.ylim(0.58,0.63)
#plt.yticks(np.arange(0.4,1.5,0.1))
plt.ylabel('$V_{out}$ [V]')
#plt.legend(loc='best')
textstr = '\n'.join((
  f'$V_{{DD}} =$ {VDD:.1f} V',
  f'$V_{{ic}} =$ {Vic:.1f} V',
  f'$V_{{outq}} =$ {Voutq:.3f} V',
  f'$V_{{os}} =$ {Vos/1e-6:.3f} $\\mu\\,V$',
  f'$V_{{outmax}} =$ {Voutmax:.3f} V',
  f'$V_{{outmin}} =$ {Voutmin:.3f} V',
  f'$V_{{swing}} =$ {Vswing:.2f} V'))
plt.text(0.65, 0.05, textstr, ha='left', va='bottom', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, 'Vout_Vid_zoom')
plt.show()

paramstr = '\n'.join((
  f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Vb1={Vb1:.1f} Vb2={Vb2:.1f} Ib={Ib/1e-9:.0f}n',
  f'.param CL={CL/1e-12:.0f}p',
  f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u AS1={AS1:.3e} PS1={PS1:.3e} AD1={AD1:.3e} PD1={PD1:.3e}',
  f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u AS2={AS2:.3e} PS2={PS2:.3e} AD2={AD2:.3e} PD2={PD2:.3e}',
  f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u AS3={AS3:.3e} PS3={PS3:.3e} AD3={AD3:.3e} PD3={PD3:.3e}',
  f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u AS4={AS4:.3e} PS4={PS4:.3e} AD4={AD4:.3e} PD4={PD4:.3e}',
  f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u AS5={AS5:.3e} PS5={PS5:.3e} AD5={AD5:.3e} PD5={PD5:.3e}',
  f'.param W7={W7/1e-6:.2f}u L7={L7/1e-6:.2f}u AS7={AS7:.3e} PS7={PS7:.3e} AD7={AD7:.3e} PD7={PD7:.3e}'
  ))
#print(paramstr)

with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
```

We can now save a more accurate value of the offset voltage $V_{os} =$ `{python} f'{Vos/1e-6:.3f}'` $\mu V$ that is required to bring the output voltage to $V_{ic} =$  `{python} f'{Vic/1e-3:.0f}'` $mV$ and that will be used for the following .AC and .NOISE simulations.

## Open-loop gain
### Closed-loop circuit
As explained above we can extract the open-loop gain from the simulated closed-loop gain with the amplifier operating as a voltage follower. The open-loop gain is then given by
\begin{equation}
  A_{open\textsf{-}loop}(\omega)= \frac{A_{closed\textsf{-}loop}(\omega)}{1 - A_{closed\textsf{-}loop}(\omega)},
\end{equation}
where $A_{closed\textsf{-}loop}(\omega)$ is the simulated closed-loop transfer function and $A_{open\textsf{-}loop}(\omega)$, the computed open-loop transfer function. The above relation assumes that the open-loop DC gain is large enough for the input-referred offset voltage to be ignored.

Note that we need to have a sufficient number of digits for the simulated closed-loop gain because the latter is very close to 1. The simulations results are shown in @fig-ng_closed_loop_gain.

```{python}
#| label: fig-ng_closed_loop_gain
#| fig-cap: "Open-loop gain response extracted from the closed-loop simulations and compared to theoretical estimation."

simtype = ".ac"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + ".dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + ".log"

if newSim:
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')
fsim=df_sim['frequency'].to_numpy()
ReAcl=df_sim['vr(out)'].to_numpy()
ImAcl=df_sim['vi(out)'].to_numpy()
Acl=ReAcl+ImAcl*1.0j
Npts=len(fsim)
fmin=fsim[0]
fmax=fsim[Npts-1]

Aol=np.zeros(Npts, dtype=complex)
AclmagdBsim=np.zeros(Npts)
AolmagdBsim=np.zeros(Npts)
Aclphidegsim=np.zeros(Npts)
Aolphidegsim=np.zeros(Npts)
AclmagdBsim=20*log(np.absolute(Acl))
Aclphidegsim=np.angle(Acl, deg=True)
#Aol=Acl/(1-Acl)
#AolmagdBsim=20*log(np.absolute(Aol))
#Aolphidegsim=np.angle(Aol, deg=True)

for k in range(0,Npts):
  Aol[k]=Acl[k]/(1-Acl[k])
  AolmagdBsim[k]=20*log(np.absolute(Aol[k]))
  Aolphidegsim[k]=np.angle(Aol[k], deg=True)
  if Aclphidegsim[k]>0:
    Aclphidegsim[k]=Aclphidegsim[k]-360
  if Aolphidegsim[k]>0:
    Aolphidegsim[k]=Aolphidegsim[k]-360

AdcdBsim=np.max(AolmagdBsim)
idx=np.where(np.diff(np.sign(AolmagdBsim)))[0]
GBWsim=fsim[idx][0]
PGBWsim=Aolphidegsim[idx][0]
PMsim=180+PGBWsim

plt.style.use('plt_style_small.mplstyle')
params = {'figure.figsize': (5,5)}
plt.rcParams.update(params)
    
fig, axs = plt.subplots(2, sharex=True)
lw=1

axs[0].semilogx([fmin,GBWsim],[0,0],'k--', linewidth=lw)
axs[0].semilogx([GBWsim,GBWsim],[0,-60],'k--', linewidth=lw)
axs[0].semilogx(fsim,AclmagdBsim,'b',label='Closed-loop gain (Simulation)')
axs[0].semilogx(fsim,AolmagdBsim,'r',label='Open-loop gain (Simulation)')
axs[0].semilogx(fthe,AmagdBthe,'r--',label='Open-loop gain (Theory)')
axs[0].set(xlim=(fmin,fmax), ylim=(-60,100), ylabel='$|A_{vd}|$ [dB]')
axs[0].set_yticks([-60,-40,-20,0,20,40,60,80,100])
axs[0].legend(loc='lower left')
textstr1 = '\n'.join((
  f'$A_{{dc}} =$ {AdcdBthe:.1f} dB (theory)',
  f'$A_{{dc}} =$ {AdcdBsim:.1f} dB (sim.)',
  f'$GBW =$ {GBWthe/1e6:.1f} GHz (theory)',
  f'$GBW =$ {GBWsim/1e6:.1f} GHz (sim.)'))
axs[0].text(0.63, 0.93, textstr1, ha='left', va='top', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogx([fmin,GBWsim],[PGBWsim,PGBWsim],'k--', linewidth=lw)
axs[1].semilogx([GBWsim,GBWsim],[PGBWsim,0],'k--', linewidth=lw)
axs[1].semilogx(fsim,Aclphidegsim,'b',label='Closed-loop gain (Simulation)')
axs[1].semilogx(fsim,Aolphidegsim,'r',label='Open-loop gain (Simulation)')
axs[1].semilogx(fthe,Aphidegthe,'r--',label='Open-loop gain (Theory)')
axs[1].set(ylim=(-180,0), xlabel='Frequency [Hz]', ylabel='$arg\\{A_{vd}\\}$ [degree]')
axs[1].set_xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
axs[1].set_yticks([-180,-135,-90,-45,0])
#axs[1].legend(loc='best')
textstr2 = '\n'.join((
  f'$PM =$ {PMthe:.1f}$^{{\\circ}}$ (theory)',
  f'$PM =$ {PMsim:.1f}$^{{\\circ}}$ (sim.)'))
axs[1].text(0.03, 0.05, textstr2, ha='left', va='bottom', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
arrow = mpatches.FancyArrowPatch((GBWsim, PGBWsim), (GBWsim, -180),
                                 arrowstyle='<|-|>', color="black", mutation_scale=15)
axs[1].add_patch(arrow)
axs[1].annotate(f'Phase margin = {PMsim:.0f}$^{{\\circ}}$ ', (0, 0.5), xycoords=arrow, ha='right', va='center', size=9)
plt.subplots_adjust(hspace=0.1)
#saveFigures(savePath, 'open_loop_gain_response')
plt.show()
```

From @fig-ng_closed_loop_gain, we see that the simulated $GBW$ is right on target but slightly smaller than the estimated value. The simulated DC gain is much smaller than the theoretical estimation but slightly above spec. We can now simulate the open-loop gain directly in open-loop configuration and compare the results to those achieved from the closed-loop simulation.

### Open-loop circuit
After having checked the operating point information, extracted the offset voltage and making sure that the OTA output is not saturated, we can now proceed with the open-loop gain simulation. The simulation results are presented in @fig-ng_open_loop_gain.

```{python}
#| label: fig-ng_open_loop_gain
#| fig-cap: "Simulated gain response compared to theoretical estimation."

simtype = ".ac"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + ".dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + ".log"

if newSim:
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')
fsim=df_sim['frequency'].to_numpy()
AmagdBsim=df_sim['AmagdB'].to_numpy()
Aphidegsim=df_sim['Aphdeg'].to_numpy()
Npts=len(fsim)
fmin=fsim[0]
#fmin=10
fmax=fsim[Npts-1]

for k in range(0,Npts):
  if Aphidegsim[k]>0:
    Aphidegsim[k]=Aphidegsim[k]-360

regexp = re.compile(r'adc' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      AdcdBsim=float(match.group(1))

regexp = re.compile(r'gbw' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      GBWsim=float(match.group(1))

regexp = re.compile(r'pgbw' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      PGBWsim=float(match.group(1))

PMsim=180+PGBWsim

plt.style.use('plt_style_small.mplstyle')
params = {'figure.figsize': (5,5)}
plt.rcParams.update(params)
    
fig, axs = plt.subplots(2, sharex=True)
lw=1

axs[0].semilogx([fmin,GBWsim],[0,0],'k--', linewidth=lw)
axs[0].semilogx([GBWsim,GBWsim],[0,-60],'k--', linewidth=lw)
axs[0].semilogx(fsim,AmagdBsim,'r',label='Simulation')
axs[0].semilogx(fthe,AmagdBthe,'r--',label='Theory')
axs[0].set(xlim=(fmin,fmax), ylim=(-60,100), ylabel='$|A_{vd}|$ [dB]')
axs[0].set_yticks([-60,-40,-20,0,20,40,60,80,100])
axs[0].legend(loc='upper right')
textstr1 = '\n'.join((
  f'$A_{{dc}} =$ {AdcdBthe:.1f} dB (theory)',
  f'$A_{{dc}} =$ {AdcdBsim:.1f} dB (sim.)',
  f'$GBW =$ {GBWthe/1e6:.1f} GHz (theory)',
  f'$GBW =$ {GBWsim/1e6:.1f} GHz (sim.)'))
axs[0].text(0.03, 0.07, textstr1, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogx([fmin,GBWsim],[PGBWsim,PGBWsim],'k--', linewidth=lw)
axs[1].semilogx([GBWsim,GBWsim],[PGBWsim,0],'k--', linewidth=lw)
axs[1].semilogx(fsim,Aphidegsim,'b',label='Simulation')
axs[1].semilogx(fthe,Aphidegthe,'b--',label='Theory')
axs[1].set(xlim=(fmin,fmax), ylim=(-180,0), xlabel='Frequency [Hz]', ylabel='$arg\\{A_{vd}\\}$ [degree]')
axs[1].set_xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
axs[1].set_yticks([-180,-135,-90,-45,0])
axs[1].legend(loc='best')
textstr2 = '\n'.join((
  f'$PM =$ {PMthe:.1f}$^{{\\circ}}$ (theory)',
  f'$PM =$ {PMsim:.1f}$^{{\\circ}}$ (sim.)'))
axs[1].text(0.03, 0.05, textstr2, ha='left', va='bottom', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
arrow = mpatches.FancyArrowPatch((GBWsim, PGBWsim), (GBWsim, -180),
                                 arrowstyle='<|-|>', color="black", mutation_scale=15)
axs[1].add_patch(arrow)
axs[1].annotate(f'Phase margin = {PMsim:.0f}$^{{\\circ}}$ ', (0, 0.5), xycoords=arrow, ha='right', va='center', size=9)
plt.subplots_adjust(hspace=0.1)
#saveFigures(savePath, 'open_loop_gain_response')
plt.show()
```

The results of the open-loop simulation in @fig-ng_open_loop_gain are very close to the result extracted from the closed-loop simulation except at high frequency (above the $GBW$ frequency). The $GBW$ is the same than the value extracted from the closed-loop simulation, smaller than the estimated one but still on target. The DC gain obtained from the open-loop simulation gain is slightly smaller than the value extracted from the closed-loop simulation and much smaller than the theoretical estimation, but still within spec. The low value of the DC gain is due to the high output conductance of nMOS transitors in this technology, while the difference between simulation and theoretical prediction is due to the poor output conductance model that is used in the design phase. 

## Input-referred noise
The simulated input-referred noise PSD is presented in @fig-ng_noise and compared to the theoretical estimation.

```{python}
#| label: fig-ng_noise
#| fig-cap: "Simulated input-referred noise PSD compared to theoretical estimation."

simtype = ".nz"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
simulationRaw = simulationPath + fileName + ".raw"
ngspiceDataFile = simulationPath + otaName + version + simtype + ".dat"
ngspiceRawFile = simulationPath + otaName + version + simtype + ".raw"
ngspiceLogFile = simulationPath + otaName + version + simtype + ".log"

if newSim:
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  shutil.copy2(simulationRaw, ngspiceRawFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

fsim=df_sim['frequency'].to_numpy()
Vnout=df_sim['onoise_spectrum'].to_numpy()
Vnin=df_sim['inoise_spectrum'].to_numpy()
SnoutdBvsim=20*log(Vnout)
SnindBvsim=20*log(Vnin)

Npts=len(fsim)
fmin=fsim[0]
fmax=fsim[Npts-1]

plt.style.use('plt_style_small.mplstyle')
plt.semilogx([fkthe,fkthe],[-150,S0dBvthe],'k--',linewidth=lw)
plt.semilogx(fsim,SnindBvsim,'r-', markevery=25, label='Total (sim.)')
plt.semilogx(fthe,SninthdBvthe,'b--', label='Thermal (theory)')
plt.semilogx(fthe,SninfldBvthe,'g--', label='Flicker (theory)')
plt.semilogx(fthe,SnindBvthe,'r--', label='Total (theory)')
plt.xlim(fmin,fmax)
plt.xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-150,-100)
plt.ylabel(r'Input Noise PSD $[dBv/\sqrt{Hz}]$')
#plt.legend(loc='best')
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
textstr = '\n'.join((
    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$ (theory)',
#    f'$S_{{nin,th}} =$ {S0dBvsim:.1f} $dBv/\\sqrt{{Hz}}$ (sim.)',
    f'$f_k =$ {fkthe/1e3:.1f} kHz (theory)'))
#    f'$f_k =$ {fksim/1e3:.1f} kHz (sim.)'))
plt.text(0.35, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, 'Input_referred_noise_PSD')
plt.show()
```

From @fig-ng_noise, we see that the simulated input-referred noise PSD is larger than the theoretical estimation for both flicker and white noise. We can have a closer look at the contributions of the various transistors to the input-referred white noise PSD.

```{python}
#| label: fig-ng_white_noise_contributions
#| fig-cap: "Breakdown of the contributions to the simulated input-referred white noise PSD."

regexp = re.compile(r'No. Variables:' + refloat)
with open(ngspiceRawFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      Nvar=int(match.group(1))

#print(Nvar)

regexp = re.compile(r'No. Points:' + refloat)
with open(ngspiceRawFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      Npts=int(match.group(1))

#print(Npts)

df_noise=pd.read_table(ngspiceRawFile, sep=r'\s+', skiprows=(31), skip_blank_lines=True, header=None, dtype=np.float64, engine='python')

freq=np.zeros(Npts)
Vnin=np.zeros(Npts)
VnoutM1a=np.zeros(Npts)
VnoutM1af=np.zeros(Npts)
VnoutM1b=np.zeros(Npts)
VnoutM1bf=np.zeros(Npts)
VnoutM2a=np.zeros(Npts)
VnoutM2af=np.zeros(Npts)
VnoutM2b=np.zeros(Npts)
VnoutM2bf=np.zeros(Npts)
VnoutM2c=np.zeros(Npts)
VnoutM2cf=np.zeros(Npts)
VnoutM2d=np.zeros(Npts)
VnoutM2df=np.zeros(Npts)
VnoutM3a=np.zeros(Npts)
VnoutM3af=np.zeros(Npts)
VnoutM3b=np.zeros(Npts)
VnoutM3bf=np.zeros(Npts)
VnoutM4=np.zeros(Npts)
VnoutM4f=np.zeros(Npts)
VnoutM7=np.zeros(Npts)
VnoutM7f=np.zeros(Npts)
Vnout=np.zeros(Npts)
SnoutM1=np.zeros(Npts)
SnoutM1f=np.zeros(Npts)
SnoutM1w=np.zeros(Npts)
SnoutM2=np.zeros(Npts)
SnoutM2f=np.zeros(Npts)
SnoutM2w=np.zeros(Npts)
SnoutM3=np.zeros(Npts)
SnoutM3f=np.zeros(Npts)
SnoutM3w=np.zeros(Npts)
SnoutM4M7=np.zeros(Npts)
SnoutM4M7f=np.zeros(Npts)
SnoutM4M7w=np.zeros(Npts)
SninM1=np.zeros(Npts)
SninM1f=np.zeros(Npts)
SninM1w=np.zeros(Npts)
SninM1dBv=np.zeros(Npts)
SninM1fdBv=np.zeros(Npts)
SninM1wdBv=np.zeros(Npts)
SninM2=np.zeros(Npts)
SninM2f=np.zeros(Npts)
SninM2w=np.zeros(Npts)
SninM2dBv=np.zeros(Npts)
SninM2fdBv=np.zeros(Npts)
SninM2wdBv=np.zeros(Npts)
SninM3=np.zeros(Npts)
SninM3f=np.zeros(Npts)
SninM3w=np.zeros(Npts)
SninM3dBv=np.zeros(Npts)
SninM3fdBv=np.zeros(Npts)
SninM3wdBv=np.zeros(Npts)
SninM4M7=np.zeros(Npts)
SninM4M7f=np.zeros(Npts)
SninM4M7w=np.zeros(Npts)
SninM4M7dBv=np.zeros(Npts)
SninM4M7fdBv=np.zeros(Npts)
SninM4M7wdBv=np.zeros(Npts)
SnoutdBv=np.zeros(Npts)
Snin=np.zeros(Npts)
SnindBv=np.zeros(Npts)
A=np.zeros(Npts)
Sninf=np.zeros(Npts)
SninfdBv=np.zeros(Npts)
Sninw=np.zeros(Npts)
SninwdBv=np.zeros(Npts)
for k in range(0,Npts):
  freq[k]=df_noise.iloc[Nvar*k,1]
  Vnin[k]=df_noise.iloc[Nvar*k+1,0]
  VnoutM1a[k]=df_noise.iloc[Nvar*k+2,0]
  VnoutM1af[k]=df_noise.iloc[Nvar*k+3,0]
  VnoutM1b[k]=df_noise.iloc[Nvar*k+4,0]
  VnoutM1bf[k]=df_noise.iloc[Nvar*k+5,0]
  VnoutM2a[k]=df_noise.iloc[Nvar*k+6,0]
  VnoutM2af[k]=df_noise.iloc[Nvar*k+7,0]
  VnoutM2b[k]=df_noise.iloc[Nvar*k+8,0]
  VnoutM2bf[k]=df_noise.iloc[Nvar*k+9,0]
  VnoutM2c[k]=df_noise.iloc[Nvar*k+10,0]
  VnoutM2cf[k]=df_noise.iloc[Nvar*k+11,0]
  VnoutM2d[k]=df_noise.iloc[Nvar*k+12,0]
  VnoutM2df[k]=df_noise.iloc[Nvar*k+13,0]
  VnoutM3a[k]=df_noise.iloc[Nvar*k+14,0]
  VnoutM3af[k]=df_noise.iloc[Nvar*k+15,0]
  VnoutM3b[k]=df_noise.iloc[Nvar*k+16,0]
  VnoutM3bf[k]=df_noise.iloc[Nvar*k+17,0]
  VnoutM4[k]=df_noise.iloc[Nvar*k+18,0]
  VnoutM4f[k]=df_noise.iloc[Nvar*k+19,0]
  VnoutM7[k]=df_noise.iloc[Nvar*k+20,0]
  VnoutM7f[k]=df_noise.iloc[Nvar*k+21,0]
  Vnout[k]=df_noise.iloc[Nvar*k+22,0]
  SnoutM1[k]=VnoutM1a[k]**2+VnoutM1b[k]**2
  SnoutM1f[k]=VnoutM1af[k]**2+VnoutM1bf[k]**2
  SnoutM1w[k]=SnoutM1[k]- SnoutM1f[k]
  SnoutM2[k]=VnoutM2a[k]**2+VnoutM2b[k]**2+VnoutM2c[k]**2+VnoutM2d[k]**2
  SnoutM2f[k]=VnoutM2af[k]**2+VnoutM2bf[k]**2+VnoutM2cf[k]**2+VnoutM2df[k]**2
  SnoutM2w[k]=SnoutM2[k]- SnoutM2f[k]
  if SnoutM2w[k] < 0:
    SnoutM2w[k] = np.nan
  SnoutM3[k]=VnoutM3a[k]**2+VnoutM3b[k]**2
  SnoutM3f[k]=VnoutM3af[k]**2+VnoutM3bf[k]**2
  SnoutM3w[k]=SnoutM3[k]- SnoutM3f[k]
  SnoutM4M7[k]=VnoutM4[k]**2+VnoutM7[k]**2
  SnoutM4M7f[k]=VnoutM4f[k]**2+VnoutM7f[k]**2
  SnoutM4M7w[k]=SnoutM4M7[k]- SnoutM4M7f[k]
  A[k]=Vnout[k]/Vnin[k]
  Snin[k]=Vnin[k]**2
  SnindBv[k]=10*log(Snin[k])
  SninM1[k]=SnoutM1[k]/A[k]**2
  SninM1f[k]=SnoutM1f[k]/A[k]**2
  SninM1w[k]=SnoutM1w[k]/A[k]**2
  SninM1dBv[k]=10*log(SninM1[k])
  SninM1fdBv[k]=10*log(SninM1f[k])
  SninM1wdBv[k]=10*log(SninM1w[k])
  SninM2[k]=SnoutM2[k]/A[k]**2
  SninM2f[k]=SnoutM2f[k]/A[k]**2
  SninM2w[k]=SnoutM2w[k]/A[k]**2
  SninM2dBv[k]=10*log(SninM2[k])
  SninM2fdBv[k]=10*log(SninM2f[k])
  SninM2wdBv[k]=10*log(SninM2w[k])
  SninM3[k]=SnoutM3[k]/A[k]**2
  SninM3f[k]=SnoutM3f[k]/A[k]**2
  SninM3w[k]=SnoutM3w[k]/A[k]**2
  SninM3dBv[k]=10*log(SninM3[k])
  SninM3fdBv[k]=10*log(SninM3f[k])
  SninM3wdBv[k]=10*log(SninM3w[k])
  SninM4M7[k]=SnoutM4M7[k]/A[k]**2
  SninM4M7f[k]=SnoutM4M7f[k]/A[k]**2
  SninM4M7w[k]=SnoutM4M7w[k]/A[k]**2
  SninM4M7dBv[k]=10*log(SninM4M7[k])
  SninM4M7fdBv[k]=10*log(SninM4M7f[k])
  SninM4M7wdBv[k]=10*log(SninM4M7w[k])
  Sninf[k]=SninM1f[k]+SninM2f[k]+SninM3f[k]+SninM4M7f[k]
  Sninw[k]=Snin[k]-Sninf[k]
  SninfdBv[k]=10*log(Sninf[k])
  SninwdBv[k]=10*log(Sninw[k])

S0sim=Sninw[0]
Rninthsim=S0sim/(4*kT)
gammanotasim=df_mos.at["M1a","Gm"]*Rninthsim

fmin=freq[0]
fmax=freq[Npts-1]

plt.style.use('plt_style_small.mplstyle')
plt.semilogx(freq,SninM1wdBv,'b-', label='M1a-M1b')
plt.semilogx(freq,SninM2wdBv,'g-', label='M2a-M2b-M2c-M2d')
plt.semilogx(freq,SninM3wdBv,'m-', label='M3a-M3b')
plt.semilogx(freq,SninM4M7wdBv,'c-', label='M4-M7')
plt.semilogx(freq,SninwdBv,'r-', label='Total (sim.)')
plt.semilogx(fthe,SninthdBvthe,'r--', label='Total (theory)')
plt.xlim(fmin,fmax)
plt.xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-200,-130)
#plt.yticks(range(-150,-100,10))
plt.ylabel('Input Noise PSD $[dBv/\\sqrt{Hz}]$')
#plt.legend(loc='lower left')
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
#textstr = '\n'.join((
#    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$ (theory)',
#    f'$S_{{nin,th}} =$ {S0dBvsim:.1f} $dBv/\\sqrt{{Hz}}$ (sim.)',
#    f'$f_k =$ {fkthe/1e3:.1f} kHz (theory)'))
#    f'$f_k =$ {fksim/1e3:.1f} kHz (sim.)'))
#plt.text(0.35, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, 'Input_referred_noise_PSD')
plt.show()
```

The contributions of M~1a~-M~1b~, M~2a~-M~2b~-M~2c~-M~2d~, M~3a~-M~3b~ and the cascode transistors M~4~ and M~7~ to the input-referred white noise PSD are detailed in @fig-ng_white_noise_contributions and compared to the theoretical white noise. We can observe that the white noise is dominated by the differential pair M~1a~-M~1b~ while the contribution of  M~2a~-M~2b~-M~2c~-M~2d~ and M~3a~-M~3b~ are lower. We also see that the contribution of the cascode transistors is more than 50 dB lower and can therefore be neglected. The total simulated white noise is slightly higher than the theoretical estimation, which is acceptable. This results in an OTA thermal noise excess factor $\gamma_{n,ota} =$  `{python} f'{gammanotasim:.3f}'` that is slightly larger than the predicted value $\gamma_{n,ota} =$  `{python} f'{gammanotathe:.3f}'`.

@fig-ng_flicker_noise_contributions presents the breakdown of the contributions of the various transistors to the input-referred flicker noise. As expected from the design, M~2a~-M~2b~-M~2c~-M~2d~ contribute about the same than M~1a~-M~1b~.

The breakdown of the contributions of the various transistors to the total input-referred noise is presented in @fig-ng_flicker_noise_contributions. We can observe that the simulation is slightly larger than the theoretical estimation.

```{python}
#| label: fig-ng_flicker_noise_contributions
#| fig-cap: "Breakdown of the contributions to the simulated input-referred flicker noise PSD."

plt.style.use('plt_style_small.mplstyle')
plt.semilogx(freq,SninM1fdBv,'b-', label='M1a-M1b')
plt.semilogx(freq,SninM2fdBv,'g-', label='M2a-M2b-M2c-M2d')
plt.semilogx(freq,SninM3fdBv,'m-', label='M3a-M3b')
plt.semilogx(freq,SninM4M7fdBv,'c-', label='M4-M7')
plt.semilogx(freq,SninfdBv,'r', label='Total (sim.)')
plt.semilogx(fthe,SninfldBvthe,'r--', label='Total (theory)')
plt.xlim(fmin,1e5)
#plt.xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-170,-100)
plt.yticks(range(-170,-90,10))
plt.ylabel('Input Noise PSD $[dBv/\\sqrt{Hz}]$')
#plt.legend(loc='lower left')
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
#textstr = '\n'.join((
#    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$ (theory)',
#    f'$S_{{nin,th}} =$ {S0dBvsim:.1f} $dBv/\\sqrt{{Hz}}$ (sim.)',
#    f'$f_k =$ {fkthe/1e3:.1f} kHz (theory)'))
#    f'$f_k =$ {fksim/1e3:.1f} kHz (sim.)'))
#plt.text(0.35, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, 'Input_referred_noise_PSD')
plt.show()
```

```{python}
#| label: fig-ng_noise_contributions
#| fig-cap: "Breakdown of the contributions to the simulated input-referred noise PSD."

plt.style.use('plt_style_small.mplstyle')
plt.semilogx(freq,SninM1dBv,'b-', label='M1a-M1b (total)')
#plt.semilogx(freq,SninM1fdBv,'b-.', label='M1a-M1b (flicker)')
#plt.semilogx(freq,SninM1wdBv,'b--', label='M1a-M1b (white)')
plt.semilogx(freq,SninM2dBv,'g-', label='M2a-M2b-M2c-M2d (total)')
#plt.semilogx(freq,SninM2fdBv,'g-.', label='M2a-M2b-M2c-M2d (flicker)')
#plt.semilogx(freq,SninM2wdBv,'g--', label='M2a-M2b-M2c-M2d (white)')
plt.semilogx(freq,SninM3dBv,'m-', label='M3a-M3b')
plt.semilogx(freq,SninM4M7dBv,'c-', label='M4-M7')
#plt.semilogx(freq,SninfdBv,'r--', label='Total (flicker)')
#plt.semilogx(freq,SninwdBv,'r-.', label='Total (white)')
plt.semilogx(freq,SnindBv,'r-', label='Total')
#plt.semilogx(fthe,SninthdBvthe,'k--', label='Thermal (theory)')
#plt.semilogx(fthe,SninfldBvthe,'k--', label='Flicker (theory)')
plt.semilogx(fthe,SnindBvthe,'r--', label='Total (theory)')
plt.xlim(fmin,fmax)
plt.xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-190,-100)
plt.yticks(range(-190,-90,10))
plt.ylabel('Input Noise PSD $[dBv/\\sqrt{Hz}]$')
#plt.legend(loc='lower left')
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
#textstr = '\n'.join((
#    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$ (theory)',
#    f'$S_{{nin,th}} =$ {S0dBvsim:.1f} $dBv/\\sqrt{{Hz}}$ (sim.)',
#    f'$f_k =$ {fkthe/1e3:.1f} kHz (theory)'))
#    f'$f_k =$ {fksim/1e3:.1f} kHz (sim.)'))
#plt.text(0.35, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, 'Input_referred_noise_PSD')
plt.show()
```

## Input common-mode voltage range
We can check the input common-mode voltage range by connecting the OTA as a voltage follower and sweeping the positive input. As shown in @fig-ng_cm_range, the output follows the input voltage up to $0.9\,V$. So the input common-mode voltage range is about $0.9\,V$.

```{python}
#| label: fig-ng_cm_range
#| fig-cap: "Simulated input common-mode voltage range."

simtype = ".dc"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + "1.dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + "1.log"

Vinmin=0
Vinmax=VDD
dVin=10e-3

if newSim:
  simpar = '\n'.join((
    f'.csparam Vinmin={Vinmin:.3e}',
    f'.csparam Vinmax={Vinmax:.3e}',
    f'.csparam dVin={dVin:.3e}'
  ))
  simparFile = simulationPath + "simulation.dc.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

Vinsim=df_sim['v-sweep'].to_numpy()
Voutsim=df_sim['Vout'].to_numpy()
plt.plot([0,0.8],[0,0.8],'k--', linewidth=lw)
#plt.plot([0,0],[0,Voutq],'k--', linewidth=lw)
#plt.plot([Vinmin,Vinmax/1e-3],[Voutmax,Voutmax],'k--', linewidth=lw)
#plt.plot([Vidmin/1e-3,Vidmax/1e-3],[Voutmin,Voutmin],'k--', linewidth=lw)
plt.plot(Vinsim,Voutsim,'r')
plt.xlim(Vinmin,Vinmax)
#plt.xticks(np.arange(-0.9,1,0.3))
plt.xlabel('$V_{in}$ [$V$]')
plt.ylim(0,1)
#plt.yticks(np.arange(0,2.2,0.2))
plt.ylabel('$V_{out}$ [V]')
#plt.legend(loc='best')
#textstr = '\n'.join((
#  f'$V_{{DD}} =$ {VDD:.1f} V',
#  f'$V_{{ic}} =$ {Vic:.1f} V',
#  f'$V_{{outq}} =$ {Voutq:.3f} V',
#  f'$V_{{outmax}} =$ {Voutmax:.3f} V',
#  f'$V_{{outmin}} =$ {Voutmin:.3f} V',
#  f'$V_{{swing}} =$ {Vswing:.2f} V'))
#plt.text(0.65, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, 'Vout_Vid')
plt.show()
```

## Step-response
```{python}
Vic=0.3
DVin=10e-3
```

In this section we will check the step response of the OTA operating as a voltage follower (output connected to the negative input) with the same load capacitance $C_L =$ `{python} f'{CL/1e-12:.0f}'` $pF$. According to the input common-mode voltage range established above, we will set the input common-mode voltage to  $V_{ic} =$ `{python} f'{Vic:.1f}'` $V$ to leave enough room for the large step.

### Small-step
We start by imposing a small step $\Delta V_{in} =$ `{python} f'{DVin/1e-3:.0f}'` $mV$ on top of a common mode voltage $V_{ic} =$ `{python} f'{Vic:.1f}'` $V$. The simulation results are shown in @fig-ng_step_small where $\Delta V_{in}(t) \triangleq V_{in+}(t) - V_{ic}$ and $\Delta V_{out}(t) \triangleq V_{out}(t) - V_{outq}$ with $V_{outq} \cong V_{ic}$ is the quiescent output voltage. $\Delta V_{in}$ and $\Delta V_{out}$ are compared to the response of a single pole circuit having a cut-off frequency equal to the $GBW$. The difference between the simulation an the first-order model is due to the larger estimated value of the $GBW$ and the additional poles introduced by the current mirrors.

```{python}
#| label: fig-ng_step_small
#| fig-cap: "Step response of the OTA as a voltage follower for a small input step."

simtype = ".tran"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
simulationVoltages = simulationPath + fileName + ".ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + "1.dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + "1.ic"

V1=Vic
V2=Vic+DVin
td=0.1e-6
tr=10e-12
tf=10e-12
pw=1
per=1
nper=0

if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Vb1={Vb1:.1f} Vb2={Vb2:.1f} Ib={Ib/1e-9:.0f}n',
    f'.param CL={CL/1e-12:.0f}p',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u AS1={AS1:.3e} PS1={PS1:.3e} AD1={AD1:.3e} PD1={PD1:.3e}',
    f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u AS2={AS2:.3e} PS2={PS2:.3e} AD2={AD2:.3e} PD2={PD2:.3e}',
    f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u AS3={AS3:.3e} PS3={PS3:.3e} AD3={AD3:.3e} PD3={PD3:.3e}',
    f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u AS4={AS4:.3e} PS4={PS4:.3e} AD4={AD4:.3e} PD4={PD4:.3e}',
    f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u AS5={AS5:.3e} PS5={PS5:.3e} AD5={AD5:.3e} PD5={PD5:.3e}',
    f'.param W7={W7/1e-6:.2f}u L7={L7/1e-6:.2f}u AS7={AS7:.3e} PS7={PS7:.3e} AD7={AD7:.3e} PD7={PD7:.3e}'
    ))
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  pulsestr = f'.param V1={V1:.3f} V2={V2:.3f} td={td:.3e} tr={tr:.3e} tf={tf:.3e} pw={pw:.3e} per={per:.3e} np={nper:.0f}'
  #print(pulsestr)
  with open(simulationPath+'pulse.par', 'w') as f:
    f.write(pulsestr)
  Nsteps=1000
  tstart=0
  tstop=1.1e-6
  tstep=(tstop-tstart)/Nsteps
  simpar = '\n'.join((
    f'.csparam tstep={tstep:.3e}',
    f'.csparam tstop={tstop:.3e}',
    f'.csparam tstart={tstart:.0f}'
    ))
  simparFile = simulationPath + "simulation.tran.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting tran simulation data file because it will be overwritten by the next tran simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)

regexp = re.compile(r'v\(out\)' + refloat)
with open(ngspiceNodeVoltageFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutq=float(match.group(1))

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

tsim=df_sim['time'].to_numpy()
Vinsim=df_sim['v(inp)'].to_numpy()
Voutsim=df_sim['v(out)'].to_numpy()
DVinsim=Vinsim-Vic
DVoutsim=Voutsim-Voutq

Npts=len(tsim)
tmin=tsim[0]
tmax=tsim[Npts-1]

#GBWthe=0.8e6
DVoutthe=np.zeros(Npts)

for k in range(0,Npts):
  if tsim[k]<td:
    DVoutthe[k]
  else:
    DVoutthe[k]=DVin*(1-exp(-2*pi*GBWthe*(tsim[k]-td)))

Adcsim=pow(10,AdcdBsim/20)
Voutfin=DVin*(1-1/Adcsim)

lw=1
plt.style.use('plt_style_small.mplstyle')
plt.plot([td/1e-6,(td+1/(2*pi*GBWthe))/1e-6],[0,DVin/1e-3], 'k--', linewidth=lw)
plt.plot([0,tmax/1e-6],[Voutfin/1e-3,Voutfin/1e-3], 'k--', linewidth=lw)
plt.plot(tsim/1e-6,DVinsim/1e-3,'b-', label='Input')
plt.plot(tsim/1e-6,DVoutthe/1e-3,'r--', label='Output (Theory)')
plt.plot(tsim/1e-6,DVoutsim/1e-3,'r-', label='Output (Sim.)')
plt.xlim(tmin/1e-6,tmax/1e-6)
plt.xticks(np.arange(0,1.2,0.1))
plt.xlabel('Time [$\\mu s$]')
plt.ylim(0,12)
plt.ylabel('$\\Delta V_{in}$, $\\Delta V_{out}$ [mV]')
plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
#saveFigures(savePath, 'Input_referred_noise_PSD')
plt.show()
```

### Large step
```{python}
DVin=0.3
```

We now impose a larger step $\Delta V_{in} =$ `{python} f'{DVin/1e-3:.0f}'` $mV$ on top of a common mode voltage $V_{ic} =$ `{python} f'{Vic/1e-3:.0f}'` $mV$. The simulation results are shown in @fig-ng_step_large where $\Delta V_{in}(t) \triangleq V_{in+}(t) - V_{ic}$ and $\Delta V_{out}(t) \triangleq V_{out}(t) - V_{outq}$ with $V_{outq} \cong V_{ic}$ is the quiescent output voltage. $\Delta V_{in}$ and $\Delta V_{out}$ are compared to the response of a single pole circuit having a cut-off frequency equal to the $GBW$. We now observe the effect of slew-rate which increases the settling time.

```{python}
#| label: fig-ng_step_large
#| fig-cap: "Step response of the OTA as a voltage follower for a large input step highlighting the slew-rate effect."

simtype = ".tran"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
simulationVoltages = simulationPath + fileName + ".ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + "2.dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + "2.ic"

V1=Vic
V2=Vic+DVin
td=0.1e-6
tr=10e-12
tf=10e-12
pw=1
per=1
nper=0

if newSim:
  pulsestr = f'.param V1={V1:.3f} V2={V2:.3f} td={td:.3e} tr={tr:.3e} tf={tf:.3e} pw={pw:.3e} per={per:.3e} np={nper:.0f}'
  with open(simulationPath+'pulse.par', 'w') as f:
    f.write(pulsestr)
  Nsteps=1000
  tstart=0
  tstop=1.1e-6
  tstep=(tstop-tstart)/Nsteps
  simpar = '\n'.join((
    f'.csparam tstep={tstep:.3e}',
    f'.csparam tstop={tstop:.3e}',
    f'.csparam tstart={tstart:.0f}'
    ))
  simparFile = simulationPath + "simulation.tran.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting tran simulation data file because it will be overwritten by the next tran simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)

regexp = re.compile(r'v\(out\)' + refloat)
with open(ngspiceNodeVoltageFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutq=float(match.group(1))

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

tsim=df_sim['time'].to_numpy()
Vinsim=df_sim['v(inp)'].to_numpy()
Voutsim=df_sim['v(out)'].to_numpy()
DVinsim=Vinsim-Vic
DVoutsim=Voutsim-Voutq

Npts=len(tsim)
tmin=tsim[0]
tmax=tsim[Npts-1]

DVoutthe=np.zeros(Npts)

for k in range(0,Npts):
  if tsim[k]<td:
    DVoutthe[k]
  else:
    DVoutthe[k]=DVin*(1-exp(-2*pi*GBWthe*(tsim[k]-td)))

Adcsim=pow(10,AdcdBsim/20)
Voutfin=DVin*(1-1/Adcsim)

lw=1
plt.style.use('plt_style_small.mplstyle')
plt.plot([td/1e-6,(td+1/(2*pi*GBWthe))/1e-6],[0,DVin/1e-3], 'k--', linewidth=lw)
plt.plot([0,tmax/1e-6],[Voutfin/1e-3,Voutfin/1e-3], 'k--', linewidth=lw)
plt.plot(tsim/1e-6,DVinsim/1e-3,'b-', label='Input')
plt.plot(tsim/1e-6,DVoutthe/1e-3,'r--', label='Output (Theory)')
plt.plot(tsim/1e-6,DVoutsim/1e-3,'r-', label='Output (Sim.)')
plt.xlim(tmin/1e-6,tmax/1e-6)
plt.xticks(np.arange(0,1.2,0.1))
plt.xlabel('Time [$\\mu s$]')
plt.ylim(0,350)
plt.ylabel('$\\Delta V_{in}$, $\\Delta V_{out}$ [mV]')
plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
#saveFigures(savePath, 'Input_referred_noise_PSD')
plt.show()
```

## Current and power consumption
```{python}
Itot=4*Ib
P=VDD*Itot
Itele=500e-9
Ptele=Itele*VDD
```

The total current consumption (without accounting for the current in M~5a~) is given by $I_{tot} =$ `{python} f'{Itot/1e-6:.3f}'` $\mu A$, resulting in a total power consumption given by $P =$ `{python} f'{P/1e-6:.3f}'` $\mu W$. We can compare the current and power consumption of the Miller OTA to the telescopic OTA $I_{tot,telescopic} \cong$ `{python} f'{Itele/1e-6:.1f}'` $\mu A$. The current and power consumption of the symmetrical cascode OTA is `{python} f'{Itot/Itele:.3f}'` times larger than that of the telescopic OTA for the same specifications and performance.

# Conclusion
This notebook presented the detailed analysis, design and verification by simulation of the symmetrical OTA @bib:krummenacher:el:1:4:1981. The analysis allowed to derive the design equations to achieve the target specifications. The OTA has been designed for specifications on the gain-bandwidth product and DC gain in the IHP SG13G2 130nm BiCMOS technology @bib:ihp:2025 using the inversion coefficient approach with the sEKV model and parameters @bib:enz:book:2006 @bib:enz:sscmag:autumn:2017 @bib:enz:sscmag:winter:2017. The design has been validated by simulations with the ngspice simulator @bib:ngspice:2024 using the PSP compact model @bib:psp103.6:2017 and the parameters provided by the open source IHP @bib:ihp:2025. The simulations have shown that the gain-bandwidth and DC gain specifications are achieved despite the limited intrinsic gain of nMOS transistors of this technology.

# References